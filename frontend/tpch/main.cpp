#include <gflags/gflags.h>

#include <algorithm>
#include <atomic>
#include <cassert>
#include <chrono>
#include <cmath>
#include <fcntl.h>
#include <fstream>
#include <iostream>
#include <numeric>
#include <optional>
#include <vector>
#include <sched.h>
#include <sstream>
#include <unordered_map>
#include <unordered_set>

#include "prototype/core/db.hpp"
#include "prototype/core/types.hpp"
#include "prototype/execution/csv_import_pipeline.hpp"
#include "prototype/execution/qep.hpp"
#include "prototype/scheduling/job_manager.hpp"
#include "prototype/storage/persistence/table.hpp"
#include "prototype/storage/policy/basic_partitioning_strategy.hpp"
#include "prototype/storage/policy/cache_partition.hpp"
#include "prototype/storage/policy/data_temp_partitioning_strategy.hpp"
#include "prototype/storage/vmcache.hpp"
#include "prototype/utils/errno.hpp"
#include "prototype/utils/print_result.hpp"
#include "queries.hpp"
#include "schema.hpp"

#ifdef VTUNE_PROFILING
#include <ittnotify.h>

__itt_domain* itt_domain = __itt_domain_create("tpch");
__itt_string_handle* itt_handle_setup = __itt_string_handle_create("setup");
__itt_string_handle* itt_handle_load = __itt_string_handle_create("load");
#endif

DEFINE_string(tpch_path, "", "Path to the TPC-H csv ([tablename].tbl) files generated by dbgen");
DEFINE_uint64(parallel, 0, "Number of threads to use; defaults to using all available threads");
DEFINE_bool(no_dirty_writeback, false, "Disable writing back dirty pages to disk; Warning: This will result in data loss!");
DEFINE_bool(no_async_flush, false, "Disable asynchronous flushing of dirty pages using idle worker threads");
DEFINE_bool(no_eviction_target, false, "Disable eviction target mechanism for avoiding interference between large temporary allocations and regular buffer pool traffic");
DEFINE_bool(exmap, false, "Use exmap (kernel module has to be loaded) to reduce vmcache overhead");
DEFINE_bool(import_only, false, "Only import input data, do not run query");
DEFINE_bool(collect_stats, false, "Collect statistics while running the queries into 'stats.csv'");
DEFINE_bool(collect_latched_page_stat, false, "Include the number of latched data pages in the collected statistics; this has high overhead as it involves iterating over all cached pages at each collection interval");
DEFINE_string(query, "q06", "Query to run; options are 'scan_nation', 'scan_lineitem', 'scan_partsupp', 'q06', 'q09_mod', and 'q09_mod_no_sel'");
DEFINE_string(partitioning_strategy, "basic", "Partitioning strategy to use in vmcache; options are 'basic' and 'partitioned' (uses separate partitions for data and temporary pages)");
DEFINE_string(eviction_policy, "clock", "Eviction policy to use within vmcache partitions; options are 'clock', 'random', and 'mru'");
DEFINE_uint64(partitioned_num_temp_pages, 0, "Number of pages to allocate to temporary data if the cache is partitioned");
DEFINE_uint64(repetitions, 10, "Number of times to repeat query execution, specify 0 to run indefinitely");
DEFINE_uint64(warmup_time, 0, "Warmup time in seconds; if not specified, the queries will simply run for the specified number of repetitions");
DEFINE_uint64(benchmark_time, 0, "Benchmark time in seconds; if not specified, the queries will simply run for the specified number of repetitions");
DEFINE_uint64(memory_limit, 16ull * 1024ull * 1024ull * 1024ull, "Memory limit");

const char CSV_SEP = '|';

std::string joinPath(const std::string& a, const std::string& b) {
    std::stringstream path_ss;
    path_ss << a;
    if (a.back() != '/')
        path_ss << "/";
    path_ss << b;
    return path_ss.str();
}

bool loadDatabase(DB& db, const ExecutionContext context) {
    std::cout << "Loading data..." << std::endl;
    std::vector<std::unique_ptr<ExecutablePipeline>> pipelines;
    // LINEITEM
    std::unordered_map<size_t, CSVColumnSpec> lineitem_column_spec;
    uint64_t lineitem_tid = db.createTable(db.default_schema_id, "LINEITEM", 11, context.getWorkerId());
    PageId lineitem_basepage_pid = db.getTableBasepageId(lineitem_tid, context.getWorkerId());
    TableBasepage* lineitem_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(lineitem_basepage_pid, context.getWorkerId()));
    lineitem_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), lineitem_basepage->column_basepages[L_ORDERKEY_CID])});
    lineitem_column_spec.insert({1, CSVColumnSpec(ParseTypeDescription::Int32(), lineitem_basepage->column_basepages[L_PARTKEY_CID])});
    lineitem_column_spec.insert({2, CSVColumnSpec(ParseTypeDescription::Int32(), lineitem_basepage->column_basepages[L_SUPPKEY_CID])});
    lineitem_column_spec.insert({3, CSVColumnSpec(ParseTypeDescription::Int32(), lineitem_basepage->column_basepages[L_LINENUMBER_CID])});
    lineitem_column_spec.insert({4, CSVColumnSpec(ParseTypeDescription::Decimal(2), lineitem_basepage->column_basepages[L_QUANTITY_CID])});
    lineitem_column_spec.insert({5, CSVColumnSpec(ParseTypeDescription::Decimal(2), lineitem_basepage->column_basepages[L_EXTENDEDPRICE_CID])});
    lineitem_column_spec.insert({6, CSVColumnSpec(ParseTypeDescription::Decimal(2), lineitem_basepage->column_basepages[L_DISCOUNT_CID])});
    lineitem_column_spec.insert({7, CSVColumnSpec(ParseTypeDescription::Decimal(2), lineitem_basepage->column_basepages[L_TAX_CID])});
    // TODO: L_RETURNFLAG
    // TODO: L_LINESTATUS
    lineitem_column_spec.insert({10, CSVColumnSpec(ParseTypeDescription::Date(), lineitem_basepage->column_basepages[L_SHIPDATE_CID])});
    lineitem_column_spec.insert({11, CSVColumnSpec(ParseTypeDescription::Date(), lineitem_basepage->column_basepages[L_COMMITDATE_CID])});
    lineitem_column_spec.insert({12, CSVColumnSpec(ParseTypeDescription::Date(), lineitem_basepage->column_basepages[L_RECEIPTDATE_CID])});
    // TODO: L_SHIPINSTRUCT
    // TODO: L_SHIPMODE
    // TODO: L_COMMENT
    pipelines.push_back(std::make_unique<CSVImportPipeline>(0, std::ref(db), joinPath(FLAGS_tpch_path, std::string("lineitem.csv")), CSV_SEP, lineitem_column_spec, 16, lineitem_basepage->visibility_basepage));

    // ORDERS
    std::unordered_map<size_t, CSVColumnSpec> orders_column_spec;
    uint64_t orders_tid = db.createTable(db.default_schema_id, "ORDERS", 5, context.getWorkerId());
    PageId orders_basepage_pid = db.getTableBasepageId(orders_tid, context.getWorkerId());
    TableBasepage* orders_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(orders_basepage_pid, context.getWorkerId()));
    orders_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), orders_basepage->column_basepages[O_ORDERKEY_CID])});
    orders_column_spec.insert({1, CSVColumnSpec(ParseTypeDescription::Int32(), orders_basepage->column_basepages[O_CUSTKEY_CID])});
    // TODO: O_ORDERSTATUS
    orders_column_spec.insert({3, CSVColumnSpec(ParseTypeDescription::Decimal(2), orders_basepage->column_basepages[O_TOTALPRICE_CID])});
    orders_column_spec.insert({4, CSVColumnSpec(ParseTypeDescription::Date(), orders_basepage->column_basepages[O_ORDERDATE_CID])});
    // TODO: O_ORDERPRIORITY
    // TODO: O_CLERK
    orders_column_spec.insert({7, CSVColumnSpec(ParseTypeDescription::Int32(), orders_basepage->column_basepages[O_SHIPPRIORITY_CID])});
    // TODO: O_COMMENT
    pipelines.push_back(std::make_unique<CSVImportPipeline>(1, std::ref(db), joinPath(FLAGS_tpch_path, std::string("orders.csv")), CSV_SEP, orders_column_spec, 9, orders_basepage->visibility_basepage));

    // PARTSUPP
    std::unordered_map<size_t, CSVColumnSpec> partsupp_column_spec;
    uint64_t partsupp_tid = db.createTable(db.default_schema_id, "PARTSUPP", 4, context.getWorkerId());
    PageId partsupp_basepage_pid = db.getTableBasepageId(partsupp_tid, context.getWorkerId());
    TableBasepage* partsupp_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(partsupp_basepage_pid, context.getWorkerId()));
    partsupp_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), partsupp_basepage->column_basepages[PS_PARTKEY_CID])});
    partsupp_column_spec.insert({1, CSVColumnSpec(ParseTypeDescription::Int32(), partsupp_basepage->column_basepages[PS_SUPPKEY_CID])});
    partsupp_column_spec.insert({2, CSVColumnSpec(ParseTypeDescription::Int32(), partsupp_basepage->column_basepages[PS_AVAILQTY_CID])});
    partsupp_column_spec.insert({3, CSVColumnSpec(ParseTypeDescription::Decimal(2), partsupp_basepage->column_basepages[PS_SUPPLYCOST_CID])});
    // TODO: PS_COMMENT
    pipelines.push_back(std::make_unique<CSVImportPipeline>(2, std::ref(db), joinPath(FLAGS_tpch_path, std::string("partsupp.csv")), CSV_SEP, partsupp_column_spec, 5, partsupp_basepage->visibility_basepage));

    // PART
    std::unordered_map<size_t, CSVColumnSpec> part_column_spec;
    uint64_t part_tid = db.createTable(db.default_schema_id, "PART", 3, context.getWorkerId());
    PageId part_basepage_pid = db.getTableBasepageId(part_tid, context.getWorkerId());
    TableBasepage* part_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(part_basepage_pid, context.getWorkerId()));
    part_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), part_basepage->column_basepages[P_PARTKEY_CID])});
    // TODO: P_NAME
    // TODO: P_MFGR
    // TODO: P_BRAND
    // TODO: P_TYPE
    part_column_spec.insert({5, CSVColumnSpec(ParseTypeDescription::Int32(), part_basepage->column_basepages[P_SIZE_CID])});
    // TODO: P_CONTAINER
    part_column_spec.insert({7, CSVColumnSpec(ParseTypeDescription::Decimal(2), part_basepage->column_basepages[P_RETAILPRICE_CID])});
    // TODO: P_COMMENT
    pipelines.push_back(std::make_unique<CSVImportPipeline>(3, std::ref(db), joinPath(FLAGS_tpch_path, std::string("part.csv")), CSV_SEP, part_column_spec, 9, part_basepage->visibility_basepage));

    // CUSTOMER
    std::unordered_map<size_t, CSVColumnSpec> customer_column_spec;
    uint64_t customer_tid = db.createTable(db.default_schema_id, "CUSTOMER", 3, context.getWorkerId());
    PageId customer_basepage_pid = db.getTableBasepageId(customer_tid, context.getWorkerId());
    TableBasepage* customer_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(customer_basepage_pid, context.getWorkerId()));
    customer_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), customer_basepage->column_basepages[C_CUSTKEY_CID])});
    // TODO: C_NAME
    // TODO: C_ADDRESS
    customer_column_spec.insert({3, CSVColumnSpec(ParseTypeDescription::Int32(), customer_basepage->column_basepages[C_NATIONKEY_CID])});
    // TODO: C_PHONE
    customer_column_spec.insert({5, CSVColumnSpec(ParseTypeDescription::Decimal(2), customer_basepage->column_basepages[C_ACCTBAL_CID])});
    // TODO: C_MKTSEGMENT
    // TODO: C_COMMENT
    pipelines.push_back(std::make_unique<CSVImportPipeline>(4, std::ref(db), joinPath(FLAGS_tpch_path, std::string("customer.csv")), CSV_SEP, customer_column_spec, 8, customer_basepage->visibility_basepage));

    // SUPPLIER
    std::unordered_map<size_t, CSVColumnSpec> supplier_column_spec;
    uint64_t supplier_tid = db.createTable(db.default_schema_id, "SUPPLIER", 3, context.getWorkerId());
    PageId supplier_basepage_pid = db.getTableBasepageId(supplier_tid, context.getWorkerId());
    TableBasepage* supplier_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(supplier_basepage_pid, context.getWorkerId()));
    supplier_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), supplier_basepage->column_basepages[S_SUPPKEY_CID])});
    // TODO: S_NAME
    // TODO: S_ADDRESS
    supplier_column_spec.insert({3, CSVColumnSpec(ParseTypeDescription::Int32(), supplier_basepage->column_basepages[S_NATIONKEY_CID])});
    // TODO: S_PHONE
    supplier_column_spec.insert({5, CSVColumnSpec(ParseTypeDescription::Decimal(2), supplier_basepage->column_basepages[S_ACCTBAL_CID])});
    // TODO: S_COMMENT
    pipelines.push_back(std::make_unique<CSVImportPipeline>(5, std::ref(db), joinPath(FLAGS_tpch_path, std::string("supplier.csv")), CSV_SEP, supplier_column_spec, 7, supplier_basepage->visibility_basepage));

    // NATION
    std::unordered_map<size_t, CSVColumnSpec> nation_column_spec;
    uint64_t nation_tid = db.createTable(db.default_schema_id, "NATION", 2, context.getWorkerId());
    PageId nation_basepage_pid = db.getTableBasepageId(nation_tid, context.getWorkerId());
    TableBasepage* nation_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(nation_basepage_pid, context.getWorkerId()));
    nation_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), nation_basepage->column_basepages[N_NATIONKEY_CID])});
    // TODO: N_NAME
    nation_column_spec.insert({2, CSVColumnSpec(ParseTypeDescription::Int32(), nation_basepage->column_basepages[N_REGIONKEY_CID])});
    // TODO: N_COMMENT
    pipelines.push_back(std::make_unique<CSVImportPipeline>(6, std::ref(db), joinPath(FLAGS_tpch_path, std::string("nation.csv")), CSV_SEP, nation_column_spec, 4, nation_basepage->visibility_basepage));

    // REGION
    std::unordered_map<size_t, CSVColumnSpec> region_column_spec;
    uint64_t region_tid = db.createTable(db.default_schema_id, "REGION", 1, context.getWorkerId());
    PageId region_basepage_pid = db.getTableBasepageId(region_tid, context.getWorkerId());
    TableBasepage* region_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(region_basepage_pid, context.getWorkerId()));
    nation_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), nation_basepage->column_basepages[R_REGIONKEY_CID])});
    // TODO: R_NAME
    // TODO: R_COMMENT
    pipelines.push_back(std::make_unique<CSVImportPipeline>(7, std::ref(db), joinPath(FLAGS_tpch_path, std::string("region.csv")), CSV_SEP, region_column_spec, 3, region_basepage->visibility_basepage));

    QEP qep(std::move(pipelines));
    qep.begin(context);
    qep.waitForExecution(context, db.vmcache);
    db.vmcache.unfixExclusive(lineitem_basepage_pid);
    db.vmcache.unfixExclusive(orders_basepage_pid);
    db.vmcache.unfixExclusive(partsupp_basepage_pid);
    db.vmcache.unfixExclusive(part_basepage_pid);
    db.vmcache.unfixExclusive(customer_basepage_pid);
    db.vmcache.unfixExclusive(supplier_basepage_pid);
    db.vmcache.unfixExclusive(nation_basepage_pid);
    db.vmcache.unfixExclusive(region_basepage_pid);

    db.vmcache.printMemoryUsage();
    return true;
}

void statsCollectorThread(bool& stop, const DB& db) {
    std::ofstream file("stats.csv");
    file << "elapsed,data_pages,temp_pages";
    if (FLAGS_collect_latched_page_stat)
        file << ",data_latched";
    file << ",temp_in_use";
    file << std::endl;
    auto begin = std::chrono::steady_clock::now();
    while (!stop) {
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
        double elapsed_seconds = std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::steady_clock::now() - begin).count();
        file << elapsed_seconds;
        file << "," << db.vmcache.getPartitions().getCurrentPhysicalDataPageCount();
        file << "," << db.vmcache.getPartitions().getCurrentPhysicalTempPageCount();
        if (FLAGS_collect_latched_page_stat)
            file << "," << db.vmcache.getNumLatchedDataPages();
        file << "," << db.vmcache.getNumTemporaryPagesInUse();
        file << std::endl;
    }
}

bool validateDatabase(DB& db) {
    const uint32_t worker_id = 0;
    std::cout << "Validating input data..." << std::endl;
    // check number of rows
    const size_t expected_num_rows = 59986052;
    PageId lineitem_basepage_pid = db.getTableBasepageId("LINEITEM", worker_id);
    PageId lineitem_visibility_root_pid = SharedGuard<TableBasepage>(db.vmcache, lineitem_basepage_pid, worker_id)->visibility_basepage;
    const size_t lineitem_cardinality = BTree<RowId, bool>(db.vmcache, lineitem_visibility_root_pid, worker_id).getCardinality();
    if (lineitem_cardinality != expected_num_rows) {
        std::cerr << "Invalid row count " << lineitem_cardinality << ". Expected " << expected_num_rows << std::endl;
        return true;
    }
    // check sums
    // TODO: reimplement with paged vectors
    /*uint64_t checksum = std::accumulate(db.quantity.begin(), db.quantity.end(), 0ul);
    if (checksum != 1530082920900ul) {
        std::cerr << "Invalid sum " << checksum << " for L_QUANTITY" << std::endl;
        return false;
    }
    checksum = std::accumulate(db.extendedprice.begin(), db.extendedprice.end(), 0ul);
    if (checksum != 2294347191940904ul) {
        std::cerr << "Invalid sum " << checksum << " for L_EXTENDEDPRICE" << std::endl;
        return false;
    }
    checksum = std::accumulate(db.discount.begin(), db.discount.end(), 0ul);
    if (checksum != 3000163644ul) {
        std::cerr << "Invalid sum " << checksum << " for L_DISCOUNT" << std::endl;
        return false;
    }*/
    return true;
}

struct QueryStream {
    QueryStream(std::string query_name, size_t repetitions)
    : query_name(std::move(query_name))
    , repetitions(repetitions)
    , current_qep(nullptr) {
        results.reserve(repetitions > 0 ? repetitions : 1);
#ifdef VTUNE_PROFILING
        // TODO: should clean this up using __itt_id_destroy()
        itt_id = __itt_id_make((void*)this->query_name.c_str(), repetitions);
        __itt_id_create(itt_domain, itt_id);
        itt_handle = __itt_string_handle_create(this->query_name.c_str());
#endif
    }

    // specification
    std::string query_name;
    size_t repetitions;

    // runtime info
#ifdef VTUNE_PROFILING
    __itt_id itt_id;
    __itt_string_handle* itt_handle;
#endif
    std::shared_ptr<QEP> current_qep;
    std::chrono::time_point<std::chrono::steady_clock> begin;
    std::vector<double> results;
};

int main(int argc, char** argv) {
#ifdef VTUNE_PROFILING
    __itt_task_begin(itt_domain, __itt_null, __itt_null, itt_handle_setup);
#endif

    gflags::ParseCommandLineFlags(&argc, &argv, true);
    if (argc != 2) {
        std::cout << "Error: Missing database path" << std::endl;
        return -1;
    }

    const char* const supported_queries[] = { "scan_nation", "scan_lineitem", "scan_partsupp", "q06", "q09_mod", "q09_mod_no_sel" };
    bool query_valid = false;
    for (size_t i = 0; i < sizeof(supported_queries) / sizeof(supported_queries[0]); i++) {
        if (FLAGS_query == supported_queries[i]) {
            query_valid = true;
            break;
        }
    }
    if (!query_valid) {
        std::cout << "Error: " << FLAGS_query << " is not a supported query" << std::endl;
        return -1;
    }

    const char* const supported_partitioning_strategies[] = { "basic", "partitioned" };
    bool partitioning_strategy_valid = false;
    for (size_t i = 0; i < sizeof(supported_partitioning_strategies) / sizeof(supported_partitioning_strategies[0]); i++) {
        if (FLAGS_partitioning_strategy == supported_partitioning_strategies[i]) {
            partitioning_strategy_valid = true;
            break;
        }
    }
    if (!partitioning_strategy_valid) {
        std::cout << "Error: " << FLAGS_partitioning_strategy << " is not a supported partitioning strategy" << std::endl;
        return -1;
    }

    const char* const supported_eviction_policies[] = { "clock", "random", "mru" };
    bool eviction_policy_valid = false;
    for (size_t i = 0; i < sizeof(supported_eviction_policies) / sizeof(supported_eviction_policies[0]); i++) {
        if (FLAGS_eviction_policy == supported_eviction_policies[i]) {
            eviction_policy_valid = true;
            break;
        }
    }
    if (!eviction_policy_valid) {
        std::cout << "Error: " << FLAGS_eviction_policy << " is not a supported eviction policy" << std::endl;
        return -1;
    }

    // path to the database file
    std::string path(argv[1]);

    // set up eviction policy
    std::unique_ptr<PartitioningStrategy> partitioning_strategy;
    if (FLAGS_partitioning_strategy == "basic") {
        partitioning_strategy = createPartitioningStrategy<BasicPartitioningStrategy>(FLAGS_eviction_policy);
    } else if (FLAGS_partitioning_strategy == "partitioned") {
        if (FLAGS_partitioned_num_temp_pages == 0) {
            std::cout << "Error: Please specify a non-zero value for 'partitioned_num_temp_pages' for the partitioned strategy!" << std::endl;
            return -1;
        }
        partitioning_strategy = createPartitioningStrategy<DataTempPartitioningStrategy>(FLAGS_eviction_policy, FLAGS_partitioned_num_temp_pages);
    }

    int ret = 0;
    {
        uint64_t num_threads = JobManager::configureNumThreads(FLAGS_parallel);
        DB db(FLAGS_memory_limit, path, false, FLAGS_no_dirty_writeback, !FLAGS_no_async_flush, !FLAGS_no_eviction_target, num_threads + 1, FLAGS_exmap, true, std::move(partitioning_strategy));
        JobManager job_manager(num_threads, db);
        ExecutionContext context(job_manager, db, 0, num_threads, false);

#ifdef VTUNE_PROFILING
        __itt_task_end(itt_domain);
#endif
        if (db.getNumTables(context.getWorkerId()) == 0) {
#ifdef VTUNE_PROFILING
            __itt_task_begin(itt_domain, __itt_null, __itt_null, itt_handle_load);
#endif
            // load data
            if (FLAGS_tpch_path.length() == 0) {
                std::cout << "Error: Missing value for argument tpch_path" << std::endl;
                ret = -1;
            } else if (!loadDatabase(db, context)) {
                ret = -1;
            }
#ifdef VTUNE_PROFILING
            __itt_task_end(itt_domain);
#endif
        }

        bool stop_stats_collection = false;
        std::unique_ptr<std::thread> stats_collector_thread;
        if (FLAGS_collect_stats) {
            // begin statistics collection
            stats_collector_thread = std::make_unique<std::thread>(statsCollectorThread, std::ref(stop_stats_collection), std::ref(db));
        }

        // run queries
        if (!FLAGS_import_only) {
            if (validateDatabase(db)) {
                const uint32_t worker_id = 0;
                std::vector<QueryStream> streams;
                std::unordered_set<size_t> finished_streams;
                streams.emplace_back(FLAGS_query, FLAGS_repetitions);
                size_t sid = 0;
                std::optional<std::chrono::time_point<std::chrono::steady_clock>> warmup_end;
                std::optional<std::chrono::time_point<std::chrono::steady_clock>> benchmark_end;
                if (FLAGS_warmup_time != 0)
                    warmup_end = std::chrono::steady_clock::now() + std::chrono::seconds(FLAGS_warmup_time);
                if (FLAGS_benchmark_time != 0)
                    benchmark_end = std::chrono::steady_clock::now() + std::chrono::seconds(FLAGS_benchmark_time + FLAGS_warmup_time);
                while (streams.size() != finished_streams.size()) {
                    sid = sid == 0 ? (streams.size() - 1) : (sid - 1);
                    if (finished_streams.find(sid) == finished_streams.end()) {
                        auto& stream = streams[sid];
                        if (!stream.current_qep || stream.current_qep->isFinished()) {
                            if (stream.current_qep) {
                                // print and record result of last execution
                                auto end = std::chrono::steady_clock::now();
#ifdef VTUNE_PROFILING
                                __itt_task_end_overlapped(itt_domain, streams[sid].itt_id);
#endif
                                printQueryResult(stream.current_qep->getResult(), worker_id);
                                stream.current_qep = nullptr;
                                if ((!warmup_end || end >= warmup_end.value()) && (!benchmark_end || end <= benchmark_end.value())) {
                                    double time = std::chrono::duration_cast<std::chrono::microseconds>(end - stream.begin).count();
                                    std::cout << "Ran " << stream.query_name << " in " << time / 1000.0 << " ms" << std::endl;
                                    stream.results.push_back(time);
                                }
                                if ((stream.repetitions != 0 && stream.results.size() == stream.repetitions) || (benchmark_end && end > benchmark_end.value())) {
                                    // this stream has finished
                                    finished_streams.insert(sid);
                                    continue;
                                }
                            }
                            // begin next execution
                            std::cout << "Running " << stream.query_name << "..." << std::endl;
#ifdef VTUNE_PROFILING
                            __itt_task_begin_overlapped(itt_domain, stream.itt_id, __itt_null, stream.itt_handle);
#endif
                            stream.begin = std::chrono::steady_clock::now();
                            stream.current_qep = getQEP(db, stream.query_name, context);
                            stream.current_qep->begin(context);
                        }
                    }
                    std::this_thread::sleep_for(std::chrono::microseconds(10));
                }
                for (size_t sid : finished_streams) {
                    auto& results = streams[sid].results;
                    if (results.size() > 2) {
                        auto beg = results.begin() + 1;
                        auto end = results.end();
                        std::cout << streams[sid].query_name << " (n=" << end - beg << "):" << std::endl;
                        std::sort(beg, end);
                        double mean = std::accumulate(beg, end, 0.0) / (end - beg);
                        double variance = 0.0;
                        for (auto t = beg; t < end; t++) {
                            double d = *t - mean;
                            variance += d * d;
                        }
                        variance /= (end - beg) - 1;
                        double stddev = std::sqrt(variance);
                        std::cout.precision(2);
                        std::cout << "\tmin  t: " << std::setfill(' ') << std::setw(9) << std::fixed << *beg / 1000.0 << " ms" << std::endl;
                        std::cout << "\tmax  t: " << std::setfill(' ') << std::setw(9) << std::fixed << *(end - 1) / 1000.0 << " ms" << std::endl;
                        std::cout << "\tmed. t: " << std::setfill(' ') << std::setw(9) << std::fixed << *(beg + (end - beg) / 2) / 1000.0 << " ms" << std::endl;
                        std::cout << "\tmean t: " << std::setfill(' ') << std::setw(9) << std::fixed << mean / 1000.0 << " ms" << std::endl;
                        std::cout << "\tstddev: " << std::setfill(' ') << std::setw(9) << std::fixed << stddev / 1000.0 << " ms" << std::endl;
                        std::cout << "\ttotal t (including warmup): " << std::setfill(' ') << std::setw(9) << std::fixed << std::accumulate(results.begin(), results.end(), 0.0) / 1000.0 << " ms" << std::endl;
                    }
                }
            } else {
                ret = -1;
            }

            if (FLAGS_collect_stats) {
                // stop statistics collection
                stop_stats_collection = true;
                stats_collector_thread->join();
            }
        }

        job_manager.stop();
    }

    return ret;
}