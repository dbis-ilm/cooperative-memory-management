#include <gflags/gflags.h>

#include <algorithm>
#include <atomic>
#include <cassert>
#include <chrono>
#include <cmath>
#include <fcntl.h>
#include <fstream>
#include <iostream>
#include <numeric>
#include <optional>
#include <vector>
#include <sched.h>
#include <sstream>
#include <unordered_map>
#include <unordered_set>
#include <set>

#include "prototype/core/db.hpp"
#include "prototype/core/types.hpp"
#include "prototype/execution/csv_import_pipeline.hpp"
#include "prototype/execution/join.hpp"
#include "prototype/execution/qep.hpp"
#include "prototype/execution/sort.hpp"
#include "prototype/scheduling/job_manager.hpp"
#include "prototype/storage/persistence/table.hpp"
#include "prototype/storage/policy/basic_partitioning_strategy.hpp"
#include "prototype/storage/policy/cache_partition.hpp"
#include "prototype/storage/policy/data_temp_partitioning_strategy.hpp"
#include "prototype/storage/vmcache.hpp"
#include "prototype/utils/errno.hpp"
#include "prototype/utils/print_result.hpp"
#include "execution/os_customer_select_index_scan.hpp"
#include "execution/os_order_select_index_scan.hpp"
#include "execution/q09_agg.hpp"
#include "execution/q09_item_scan.hpp"
#include "execution/q09_order_scan.hpp"
#include "execution/q09_stock_scan.hpp"
#include "schema.hpp"

#ifdef VTUNE_PROFILING
#include <ittnotify.h>

__itt_domain* itt_domain = __itt_domain_create("tpcch");
__itt_string_handle* itt_handle_setup = __itt_string_handle_create("setup");
__itt_string_handle* itt_handle_load = __itt_string_handle_create("load");
#endif

DEFINE_string(ch_path, "", "Path to the CH csv ([tablename].tbl) files generated by dbgen");
DEFINE_uint64(parallel, 0, "Number of threads to use; defaults to using all available threads");
DEFINE_uint64(oltp, 64, "Number of concurrent OLTP streams to run");
DEFINE_bool(real_olap, false, "Whether a real OLAP query should be run instead of an emulated one");
DEFINE_uint64(warmup, 10, "Warmup time in seconds");
DEFINE_uint64(benchmark, 60, "Benchmark time in seconds");
DEFINE_bool(import_only, false, "Only import input data, do not run query");
DEFINE_bool(full_validation, false, "Perform full validation; without this flag, the cardinality of large indices is not validated");
DEFINE_string(collect_stats, "", "Collect statistics while running the queries into the specified path in CSV format");
DEFINE_string(latency_log, "", "Collect measured latencies for queries/transactions into the specified path in CSV format");
DEFINE_bool(collect_latched_page_stat, false, "Include the number of latched data pages in the collected statistics; this has high overhead as it involves iterating over all cached pages at each collection interval");
DEFINE_string(partitioning_strategy, "basic", "Partitioning strategy to use in vmcache; options are 'basic' and 'partitioned' (uses separate partitions for data and temporary pages)");
DEFINE_string(eviction_policy, "clock", "Eviction policy to use within vmcache partitions; options are 'clock', 'random', and 'mru'");
DEFINE_uint64(partitioned_num_temp_pages, 0, "Number of pages to allocate to temporary data if the cache is partitioned");
DEFINE_uint64(memory_limit, 16ull * 1024ull * 1024ull * 1024ull, "Memory limit");

const char CSV_SEP = '|';

const auto W_ID = NamedColumn(std::string("W_ID"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto W_NAME = NamedColumn(std::string("W_NAME"), std::make_shared<UnencodedTemporaryColumn<Char<10>>>());
const auto W_STREET_1 = NamedColumn(std::string("W_STREET_1"), std::make_shared<UnencodedTemporaryColumn<Char<20>>>());
const auto W_STREET_2 = NamedColumn(std::string("W_STREET_2"), std::make_shared<UnencodedTemporaryColumn<Char<20>>>());
const auto W_CITY = NamedColumn(std::string("W_CITY"), std::make_shared<UnencodedTemporaryColumn<Char<20>>>());
const auto W_STATE = NamedColumn(std::string("W_STATE"), std::make_shared<UnencodedTemporaryColumn<Char<2>>>());
const auto W_ZIP = NamedColumn(std::string("W_ZIP"), std::make_shared<UnencodedTemporaryColumn<Char<9>>>());
const auto W_TAX = NamedColumn(std::string("W_TAX"), std::make_shared<UnencodedTemporaryColumn<Decimal<4>>>());
const auto W_YTD = NamedColumn(std::string("W_YTD"), std::make_shared<UnencodedTemporaryColumn<Decimal<2>>>());

const auto D_TAX = NamedColumn(std::string("D_TAX"), std::make_shared<UnencodedTemporaryColumn<Decimal<4>>>());
const auto D_NEXT_O_ID = NamedColumn(std::string("D_NEXT_O_ID"), std::make_shared<UnencodedTemporaryColumn<Integer>>());
const auto C_ID = NamedColumn(std::string("C_ID"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto C_FIRST = NamedColumn(std::string("C_FIRST"), std::make_shared<UnencodedTemporaryColumn<Char<16>>>());
const auto C_MIDDLE = NamedColumn(std::string("C_MIDDLE"), std::make_shared<UnencodedTemporaryColumn<Char<2>>>());
const auto C_LAST = NamedColumn(std::string("C_LAST"), std::make_shared<UnencodedTemporaryColumn<Char<16>>>());
const auto C_DISCOUNT = NamedColumn(std::string("C_DISCOUNT"), std::make_shared<UnencodedTemporaryColumn<Decimal<4>>>());
const auto C_BALANCE = NamedColumn(std::string("C_BALANCE"), std::make_shared<UnencodedTemporaryColumn<Decimal<2>>>());
const auto C_CREDIT = NamedColumn(std::string("C_CREDIT"), std::make_shared<UnencodedTemporaryColumn<Char<2>>>());
const auto I_PRICE = NamedColumn(std::string("I_PRICE"), std::make_shared<UnencodedTemporaryColumn<Decimal<2>>>());
const auto S_SUPPKEY = NamedColumn(std::string("S_SUPPKEY"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto S_QUANTITY = NamedColumn(std::string("S_QUANTITY"), std::make_shared<UnencodedTemporaryColumn<Integer>>());
const auto S_DIST = NamedColumn(std::string("S_DIST"), std::make_shared<UnencodedTemporaryColumn<Char<24>>>());
const auto S_YTD = NamedColumn(std::string("S_YTD"), std::make_shared<UnencodedTemporaryColumn<Integer>>());
const auto S_ORDER_CNT = NamedColumn(std::string("S_ORDER_CNT"), std::make_shared<UnencodedTemporaryColumn<Integer>>());
const auto S_REMOTE_CNT = NamedColumn(std::string("S_REMOTE_CNT"), std::make_shared<UnencodedTemporaryColumn<Integer>>());
const auto OL_W_ID = NamedColumn(std::string("OL_W_ID"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto OL_D_ID = NamedColumn(std::string("OL_D_ID"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto OL_O_ID = NamedColumn(std::string("OL_O_ID"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto OL_I_ID = NamedColumn(std::string("OL_I_ID"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto OL_SUPPLY_W_ID = NamedColumn(std::string("OL_SUPPLY_W_ID"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto OL_QUANTITY = NamedColumn(std::string("OL_QUANTITY"), std::make_shared<UnencodedTemporaryColumn<Integer>>());
const auto OL_AMOUNT = NamedColumn(std::string("OL_AMOUNT"), std::make_shared<UnencodedTemporaryColumn<Decimal<2>>>());
const auto OL_DELIVERY_D = NamedColumn(std::string("OL_DELIVERY_D"), std::make_shared<UnencodedTemporaryColumn<DateTime>>());
const auto N_NATIONKEY = NamedColumn(std::string("N_NATIONKEY"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto N_NAME = NamedColumn(std::string("N_NAME"), std::make_shared<UnencodedTemporaryColumn<Char<25>>>());
const auto SU_NATIONKEY = NamedColumn(std::string("SU_NATIONKEY"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto SU_SUPPKEY = NamedColumn(std::string("SU_SUPPKEY"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto S_W_ID = NamedColumn(std::string("S_W_ID"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto S_I_ID = NamedColumn(std::string("S_I_ID"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto O_ID = NamedColumn(std::string("O_ID"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto O_W_ID = NamedColumn(std::string("O_W_ID"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto O_D_ID = NamedColumn(std::string("O_D_ID"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto O_ENTRY_D = NamedColumn(std::string("O_ENTRY_D"), std::make_shared<UnencodedTemporaryColumn<DateTime>>());
const auto O_CARRIER_ID = NamedColumn(std::string("O_CARRIER_ID"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto I_ID = NamedColumn(std::string("I_ID"), std::make_shared<UnencodedTemporaryColumn<Identifier>>());
const auto L_YEAR = NamedColumn(std::string("L_YEAR"), std::make_shared<UnencodedTemporaryColumn<Integer>>());
const auto SUM_PROFIT = NamedColumn(std::string("SUM_PROFIT"), std::make_shared<UnencodedTemporaryColumn<Decimal<2>>>());

std::string joinPath(const std::string& a, const std::string& b) {
    std::stringstream path_ss;
    path_ss << a;
    if (a.back() != '/')
        path_ss << "/";
    path_ss << b;
    return path_ss.str();
}

class UnexpectedCardinalityError : public std::exception {
public:
    UnexpectedCardinalityError(const std::string& object, size_t cardinality, size_t expected_cardinality) {
        std::stringstream err_msg_strstr;
        err_msg_strstr << object << " has cardinality " << cardinality << ", expected " << expected_cardinality;
        err_msg = err_msg_strstr.str();
    }

    const char* what() const noexcept override { return err_msg.c_str(); }

private:
    std::string err_msg;
};

bool loadDatabase(DB& db, const ExecutionContext context) {
    std::cout << "Loading data..." << std::endl;
    std::vector<std::unique_ptr<ExecutablePipeline>> pipelines;
    // WAREHOUSE
    std::unordered_map<size_t, CSVColumnSpec> warehouse_column_spec;
    uint64_t warehouse_tid = db.createTable(db.default_schema_id, "WAREHOUSE", 9, context.getWorkerId());
    PageId warehouse_basepage_pid = db.getTableBasepageId(warehouse_tid, context.getWorkerId());
    TableBasepage* warehouse_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(warehouse_basepage_pid, context.getWorkerId()));
    warehouse_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), warehouse_basepage->column_basepages[W_ID_CID])});
    warehouse_column_spec.insert({1, CSVColumnSpec(ParseTypeDescription::Char(10), warehouse_basepage->column_basepages[W_NAME_CID])});
    warehouse_column_spec.insert({2, CSVColumnSpec(ParseTypeDescription::Char(20), warehouse_basepage->column_basepages[W_STREET_1_CID])});
    warehouse_column_spec.insert({3, CSVColumnSpec(ParseTypeDescription::Char(20), warehouse_basepage->column_basepages[W_STREET_2_CID])});
    warehouse_column_spec.insert({4, CSVColumnSpec(ParseTypeDescription::Char(20), warehouse_basepage->column_basepages[W_CITY_CID])});
    warehouse_column_spec.insert({5, CSVColumnSpec(ParseTypeDescription::Char(2), warehouse_basepage->column_basepages[W_STATE_CID])});
    warehouse_column_spec.insert({6, CSVColumnSpec(ParseTypeDescription::Char(9), warehouse_basepage->column_basepages[W_ZIP_CID])});
    warehouse_column_spec.insert({7, CSVColumnSpec(ParseTypeDescription::Decimal(4), warehouse_basepage->column_basepages[W_TAX_CID])});
    warehouse_column_spec.insert({8, CSVColumnSpec(ParseTypeDescription::Decimal(2), warehouse_basepage->column_basepages[W_YTD_CID])});
    pipelines.push_back(std::make_unique<CSVImportPipeline>(0, std::ref(db), joinPath(FLAGS_ch_path, std::string("WAREHOUSE.tbl")), CSV_SEP, warehouse_column_spec, 9, std::ref(warehouse_basepage->cardinality)));

    // DISTRICT
    std::unordered_map<size_t, CSVColumnSpec> district_column_spec;
    uint64_t district_tid = db.createTable(db.default_schema_id, "DISTRICT", 11, context.getWorkerId());
    PageId district_basepage_pid = db.getTableBasepageId(district_tid, context.getWorkerId());
    TableBasepage* district_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(district_basepage_pid, context.getWorkerId()));
    district_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), district_basepage->column_basepages[D_ID_CID])});
    district_column_spec.insert({1, CSVColumnSpec(ParseTypeDescription::Int32(), district_basepage->column_basepages[D_W_ID_CID])});
    district_column_spec.insert({2, CSVColumnSpec(ParseTypeDescription::Char(10), district_basepage->column_basepages[D_NAME_CID])});
    district_column_spec.insert({3, CSVColumnSpec(ParseTypeDescription::Char(20), district_basepage->column_basepages[D_STREET_1_CID])});
    district_column_spec.insert({4, CSVColumnSpec(ParseTypeDescription::Char(20), district_basepage->column_basepages[D_STREET_2_CID])});
    district_column_spec.insert({5, CSVColumnSpec(ParseTypeDescription::Char(20), district_basepage->column_basepages[D_CITY_CID])});
    district_column_spec.insert({6, CSVColumnSpec(ParseTypeDescription::Char(2), district_basepage->column_basepages[D_STATE_CID])});
    district_column_spec.insert({7, CSVColumnSpec(ParseTypeDescription::Char(9), district_basepage->column_basepages[D_ZIP_CID])});
    district_column_spec.insert({8, CSVColumnSpec(ParseTypeDescription::Decimal(4), district_basepage->column_basepages[D_TAX_CID])});
    district_column_spec.insert({9, CSVColumnSpec(ParseTypeDescription::Decimal(2), district_basepage->column_basepages[D_YTD_CID])});
    district_column_spec.insert({10, CSVColumnSpec(ParseTypeDescription::Int32(), district_basepage->column_basepages[D_NEXT_O_ID_CID])});
    pipelines.push_back(std::make_unique<CSVImportPipeline>(1, std::ref(db), joinPath(FLAGS_ch_path, std::string("DISTRICT.tbl")), CSV_SEP, district_column_spec, 11, std::ref(district_basepage->cardinality)));
    pipelines.back()->addDependency(pipelines.size() - 2);

    // CUSTOMER
    std::unordered_map<size_t, CSVColumnSpec> customer_column_spec;
    uint64_t customer_tid = db.createTable(db.default_schema_id, "CUSTOMER", 22, context.getWorkerId());
    PageId customer_basepage_pid = db.getTableBasepageId(customer_tid, context.getWorkerId());
    TableBasepage* customer_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(customer_basepage_pid, context.getWorkerId()));
    customer_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), customer_basepage->column_basepages[C_ID_CID])});
    customer_column_spec.insert({1, CSVColumnSpec(ParseTypeDescription::Int32(), customer_basepage->column_basepages[C_D_ID_CID])});
    customer_column_spec.insert({2, CSVColumnSpec(ParseTypeDescription::Int32(), customer_basepage->column_basepages[C_W_ID_CID])});
    customer_column_spec.insert({3, CSVColumnSpec(ParseTypeDescription::Char(16), customer_basepage->column_basepages[C_FIRST_CID])});
    customer_column_spec.insert({4, CSVColumnSpec(ParseTypeDescription::Char(2), customer_basepage->column_basepages[C_MIDDLE_CID])});
    customer_column_spec.insert({5, CSVColumnSpec(ParseTypeDescription::Char(16), customer_basepage->column_basepages[C_LAST_CID])});
    customer_column_spec.insert({6, CSVColumnSpec(ParseTypeDescription::Char(20), customer_basepage->column_basepages[C_STREET_1_CID])});
    customer_column_spec.insert({7, CSVColumnSpec(ParseTypeDescription::Char(20), customer_basepage->column_basepages[C_STREET_2_CID])});
    customer_column_spec.insert({8, CSVColumnSpec(ParseTypeDescription::Char(20), customer_basepage->column_basepages[C_CITY_CID])});
    customer_column_spec.insert({9, CSVColumnSpec(ParseTypeDescription::Char(2), customer_basepage->column_basepages[C_STATE_CID])});
    customer_column_spec.insert({10, CSVColumnSpec(ParseTypeDescription::Char(9), customer_basepage->column_basepages[C_ZIP_CID])});
    customer_column_spec.insert({11, CSVColumnSpec(ParseTypeDescription::Char(16), customer_basepage->column_basepages[C_PHONE_CID])});
    customer_column_spec.insert({12, CSVColumnSpec(ParseTypeDescription::DateTime(), customer_basepage->column_basepages[C_SINCE_CID])});
    customer_column_spec.insert({13, CSVColumnSpec(ParseTypeDescription::Char(2), customer_basepage->column_basepages[C_CREDIT_CID])});
    customer_column_spec.insert({14, CSVColumnSpec(ParseTypeDescription::Decimal(2), customer_basepage->column_basepages[C_CREDIT_LIM_CID])});
    customer_column_spec.insert({15, CSVColumnSpec(ParseTypeDescription::Decimal(4), customer_basepage->column_basepages[C_DISCOUNT_CID])});
    customer_column_spec.insert({16, CSVColumnSpec(ParseTypeDescription::Decimal(2), customer_basepage->column_basepages[C_BALANCE_CID])});
    customer_column_spec.insert({17, CSVColumnSpec(ParseTypeDescription::Decimal(2), customer_basepage->column_basepages[C_YTD_PAYMENT_CID])});
    customer_column_spec.insert({18, CSVColumnSpec(ParseTypeDescription::Int32(), customer_basepage->column_basepages[C_PAYMENT_CNT_CID])});
    customer_column_spec.insert({19, CSVColumnSpec(ParseTypeDescription::Int32(), customer_basepage->column_basepages[C_DELIVERY_CNT_CID])});
    customer_column_spec.insert({20, CSVColumnSpec(ParseTypeDescription::Char(500), customer_basepage->column_basepages[C_DATA_CID])});
    customer_column_spec.insert({21, CSVColumnSpec(ParseTypeDescription::Int32(), customer_basepage->column_basepages[C_N_NATIONKEY_CID])});
    pipelines.push_back(std::make_unique<CSVImportPipeline>(2, std::ref(db), joinPath(FLAGS_ch_path, std::string("CUSTOMER.tbl")), CSV_SEP, customer_column_spec, 22, std::ref(customer_basepage->cardinality)));
    pipelines.back()->addDependency(pipelines.size() - 2);

    // HISTORY
    std::unordered_map<size_t, CSVColumnSpec> history_column_spec;
    uint64_t history_tid = db.createTable(db.default_schema_id, "HISTORY", 8, context.getWorkerId());
    PageId history_basepage_pid = db.getTableBasepageId(history_tid, context.getWorkerId());
    TableBasepage* history_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(history_basepage_pid, context.getWorkerId()));
    history_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), history_basepage->column_basepages[H_C_ID_CID])});
    history_column_spec.insert({1, CSVColumnSpec(ParseTypeDescription::Int32(), history_basepage->column_basepages[H_C_D_ID_CID])});
    history_column_spec.insert({2, CSVColumnSpec(ParseTypeDescription::Int32(), history_basepage->column_basepages[H_C_W_ID_CID])});
    history_column_spec.insert({3, CSVColumnSpec(ParseTypeDescription::Int32(), history_basepage->column_basepages[H_D_ID_CID])});
    history_column_spec.insert({4, CSVColumnSpec(ParseTypeDescription::Int32(), history_basepage->column_basepages[H_W_ID_CID])});
    history_column_spec.insert({5, CSVColumnSpec(ParseTypeDescription::DateTime(), history_basepage->column_basepages[H_DATE_CID])});
    history_column_spec.insert({6, CSVColumnSpec(ParseTypeDescription::Decimal(2), history_basepage->column_basepages[H_AMOUNT_CID])});
    history_column_spec.insert({7, CSVColumnSpec(ParseTypeDescription::Char(24), history_basepage->column_basepages[H_DATA_CID])});
    pipelines.push_back(std::make_unique<CSVImportPipeline>(3, std::ref(db), joinPath(FLAGS_ch_path, std::string("HISTORY.tbl")), CSV_SEP, history_column_spec, 8, std::ref(history_basepage->cardinality)));
    pipelines.back()->addDependency(pipelines.size() - 2);

    // NEWORDER
    std::unordered_map<size_t, CSVColumnSpec> neworder_column_spec;
    uint64_t neworder_tid = db.createTable(db.default_schema_id, "NEWORDER", 3, context.getWorkerId());
    PageId neworder_basepage_pid = db.getTableBasepageId(neworder_tid, context.getWorkerId());
    TableBasepage* neworder_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(neworder_basepage_pid, context.getWorkerId()));
    neworder_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), neworder_basepage->column_basepages[NO_O_ID_CID])});
    neworder_column_spec.insert({1, CSVColumnSpec(ParseTypeDescription::Int32(), neworder_basepage->column_basepages[NO_D_ID_CID])});
    neworder_column_spec.insert({2, CSVColumnSpec(ParseTypeDescription::Int32(), neworder_basepage->column_basepages[NO_W_ID_CID])});
    pipelines.push_back(std::make_unique<CSVImportPipeline>(4, std::ref(db), joinPath(FLAGS_ch_path, std::string("NEWORDER.tbl")), CSV_SEP, neworder_column_spec, 3, std::ref(neworder_basepage->cardinality)));
    pipelines.back()->addDependency(pipelines.size() - 2);

    // ORDER
    std::unordered_map<size_t, CSVColumnSpec> order_column_spec;
    uint64_t order_tid = db.createTable(db.default_schema_id, "ORDER", 8, context.getWorkerId());
    PageId order_basepage_pid = db.getTableBasepageId(order_tid, context.getWorkerId());
    TableBasepage* order_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(order_basepage_pid, context.getWorkerId()));
    order_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), order_basepage->column_basepages[O_ID_CID])});
    order_column_spec.insert({1, CSVColumnSpec(ParseTypeDescription::Int32(), order_basepage->column_basepages[O_D_ID_CID])});
    order_column_spec.insert({2, CSVColumnSpec(ParseTypeDescription::Int32(), order_basepage->column_basepages[O_W_ID_CID])});
    order_column_spec.insert({3, CSVColumnSpec(ParseTypeDescription::Int32(), order_basepage->column_basepages[O_C_ID_CID])});
    order_column_spec.insert({4, CSVColumnSpec(ParseTypeDescription::DateTime(), order_basepage->column_basepages[O_ENTRY_D_CID])});
    order_column_spec.insert({5, CSVColumnSpec(ParseTypeDescription::Int32(), order_basepage->column_basepages[O_CARRIER_ID_CID])});
    order_column_spec.insert({6, CSVColumnSpec(ParseTypeDescription::Int32(), order_basepage->column_basepages[O_OL_CNT_CID])});
    order_column_spec.insert({7, CSVColumnSpec(ParseTypeDescription::Int32(), order_basepage->column_basepages[O_ALL_LOCAL_CID])});
    pipelines.push_back(std::make_unique<CSVImportPipeline>(5, std::ref(db), joinPath(FLAGS_ch_path, std::string("ORDER.tbl")), CSV_SEP, order_column_spec, 8, std::ref(order_basepage->cardinality)));
    pipelines.back()->addDependency(pipelines.size() - 2);

    // ORDERLINE
    std::unordered_map<size_t, CSVColumnSpec> orderline_column_spec;
    uint64_t orderline_tid = db.createTable(db.default_schema_id, "ORDERLINE", 10, context.getWorkerId());
    PageId orderline_basepage_pid = db.getTableBasepageId(orderline_tid, context.getWorkerId());
    TableBasepage* orderline_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(orderline_basepage_pid, context.getWorkerId()));
    orderline_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), orderline_basepage->column_basepages[OL_O_ID_CID])});
    orderline_column_spec.insert({1, CSVColumnSpec(ParseTypeDescription::Int32(), orderline_basepage->column_basepages[OL_D_ID_CID])});
    orderline_column_spec.insert({2, CSVColumnSpec(ParseTypeDescription::Int32(), orderline_basepage->column_basepages[OL_W_ID_CID])});
    orderline_column_spec.insert({3, CSVColumnSpec(ParseTypeDescription::Int32(), orderline_basepage->column_basepages[OL_NUMBER_CID])});
    orderline_column_spec.insert({4, CSVColumnSpec(ParseTypeDescription::Int32(), orderline_basepage->column_basepages[OL_I_ID_CID])});
    orderline_column_spec.insert({5, CSVColumnSpec(ParseTypeDescription::Int32(), orderline_basepage->column_basepages[OL_SUPPLY_W_ID_CID])});
    orderline_column_spec.insert({6, CSVColumnSpec(ParseTypeDescription::DateTime(), orderline_basepage->column_basepages[OL_DELIVERY_D_CID])});
    orderline_column_spec.insert({7, CSVColumnSpec(ParseTypeDescription::Int32(), orderline_basepage->column_basepages[OL_QUANTITY_CID])});
    orderline_column_spec.insert({8, CSVColumnSpec(ParseTypeDescription::Decimal(2), orderline_basepage->column_basepages[OL_AMOUNT_CID])});
    orderline_column_spec.insert({9, CSVColumnSpec(ParseTypeDescription::Char(24), orderline_basepage->column_basepages[OL_DIST_INFO_CID])});
    pipelines.push_back(std::make_unique<CSVImportPipeline>(6, std::ref(db), joinPath(FLAGS_ch_path, std::string("ORDERLINE.tbl")), CSV_SEP, orderline_column_spec, 10, std::ref(orderline_basepage->cardinality)));
    pipelines.back()->addDependency(pipelines.size() - 2);

    // ITEM
    std::unordered_map<size_t, CSVColumnSpec> item_column_spec;
    uint64_t item_tid = db.createTable(db.default_schema_id, "ITEM", 5, context.getWorkerId());
    PageId item_basepage_pid = db.getTableBasepageId(item_tid, context.getWorkerId());
    TableBasepage* item_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(item_basepage_pid, context.getWorkerId()));
    item_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), item_basepage->column_basepages[I_ID_CID])});
    item_column_spec.insert({1, CSVColumnSpec(ParseTypeDescription::Int32(), item_basepage->column_basepages[I_IM_ID_CID])});
    item_column_spec.insert({2, CSVColumnSpec(ParseTypeDescription::Char(24), item_basepage->column_basepages[I_NAME_CID])});
    item_column_spec.insert({3, CSVColumnSpec(ParseTypeDescription::Decimal(2), item_basepage->column_basepages[I_PRICE_CID])});
    item_column_spec.insert({4, CSVColumnSpec(ParseTypeDescription::Char(50), item_basepage->column_basepages[I_DATA_CID])});
    pipelines.push_back(std::make_unique<CSVImportPipeline>(7, std::ref(db), joinPath(FLAGS_ch_path, std::string("ITEM.tbl")), CSV_SEP, item_column_spec, 5, std::ref(item_basepage->cardinality)));
    pipelines.back()->addDependency(pipelines.size() - 2);

    // STOCK
    std::unordered_map<size_t, CSVColumnSpec> stock_column_spec;
    uint64_t stock_tid = db.createTable(db.default_schema_id, "STOCK", 18, context.getWorkerId());
    PageId stock_basepage_pid = db.getTableBasepageId(stock_tid, context.getWorkerId());
    TableBasepage* stock_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(stock_basepage_pid, context.getWorkerId()));
    stock_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), stock_basepage->column_basepages[S_I_ID_CID])});
    stock_column_spec.insert({1, CSVColumnSpec(ParseTypeDescription::Int32(), stock_basepage->column_basepages[S_W_ID_CID])});
    stock_column_spec.insert({2, CSVColumnSpec(ParseTypeDescription::Int32(), stock_basepage->column_basepages[S_QUANTITY_CID])});
    stock_column_spec.insert({3, CSVColumnSpec(ParseTypeDescription::Char(24), stock_basepage->column_basepages[S_DIST_01_CID])});
    stock_column_spec.insert({4, CSVColumnSpec(ParseTypeDescription::Char(24), stock_basepage->column_basepages[S_DIST_02_CID])});
    stock_column_spec.insert({5, CSVColumnSpec(ParseTypeDescription::Char(24), stock_basepage->column_basepages[S_DIST_03_CID])});
    stock_column_spec.insert({6, CSVColumnSpec(ParseTypeDescription::Char(24), stock_basepage->column_basepages[S_DIST_04_CID])});
    stock_column_spec.insert({7, CSVColumnSpec(ParseTypeDescription::Char(24), stock_basepage->column_basepages[S_DIST_05_CID])});
    stock_column_spec.insert({8, CSVColumnSpec(ParseTypeDescription::Char(24), stock_basepage->column_basepages[S_DIST_06_CID])});
    stock_column_spec.insert({9, CSVColumnSpec(ParseTypeDescription::Char(24), stock_basepage->column_basepages[S_DIST_07_CID])});
    stock_column_spec.insert({10, CSVColumnSpec(ParseTypeDescription::Char(24), stock_basepage->column_basepages[S_DIST_08_CID])});
    stock_column_spec.insert({11, CSVColumnSpec(ParseTypeDescription::Char(24), stock_basepage->column_basepages[S_DIST_09_CID])});
    stock_column_spec.insert({12, CSVColumnSpec(ParseTypeDescription::Char(24), stock_basepage->column_basepages[S_DIST_10_CID])});
    stock_column_spec.insert({13, CSVColumnSpec(ParseTypeDescription::Int32(), stock_basepage->column_basepages[S_YTD_CID])});
    stock_column_spec.insert({14, CSVColumnSpec(ParseTypeDescription::Int32(), stock_basepage->column_basepages[S_ORDER_CNT_CID])});
    stock_column_spec.insert({15, CSVColumnSpec(ParseTypeDescription::Int32(), stock_basepage->column_basepages[S_REMOTE_CNT_CID])});
    stock_column_spec.insert({16, CSVColumnSpec(ParseTypeDescription::Char(50), stock_basepage->column_basepages[S_DATA_CID])});
    stock_column_spec.insert({17, CSVColumnSpec(ParseTypeDescription::Int32(), stock_basepage->column_basepages[S_SU_SUPPKEY_CID])});
    pipelines.push_back(std::make_unique<CSVImportPipeline>(8, std::ref(db), joinPath(FLAGS_ch_path, std::string("STOCK.tbl")), CSV_SEP, stock_column_spec, 18, std::ref(stock_basepage->cardinality)));
    pipelines.back()->addDependency(pipelines.size() - 2);

    // NATION
    std::unordered_map<size_t, CSVColumnSpec> nation_column_spec;
    uint64_t nation_tid = db.createTable(db.default_schema_id, "NATION", 4, context.getWorkerId());
    PageId nation_basepage_pid = db.getTableBasepageId(nation_tid, context.getWorkerId());
    TableBasepage* nation_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(nation_basepage_pid, context.getWorkerId()));
    nation_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), nation_basepage->column_basepages[N_NATIONKEY_CID])});
    nation_column_spec.insert({1, CSVColumnSpec(ParseTypeDescription::Char(25), nation_basepage->column_basepages[N_NAME_CID])});
    nation_column_spec.insert({2, CSVColumnSpec(ParseTypeDescription::Int32(), nation_basepage->column_basepages[N_REGIONKEY_CID])});
    nation_column_spec.insert({3, CSVColumnSpec(ParseTypeDescription::Char(152), nation_basepage->column_basepages[N_COMMENT_CID])});
    pipelines.push_back(std::make_unique<CSVImportPipeline>(9, std::ref(db), joinPath(FLAGS_ch_path, std::string("NATION.tbl")), CSV_SEP, nation_column_spec, 4, std::ref(nation_basepage->cardinality)));
    pipelines.back()->addDependency(pipelines.size() - 2);

    // SUPPLIER
    std::unordered_map<size_t, CSVColumnSpec> supplier_column_spec;
    uint64_t supplier_tid = db.createTable(db.default_schema_id, "SUPPLIER", 7, context.getWorkerId());
    PageId supplier_basepage_pid = db.getTableBasepageId(supplier_tid, context.getWorkerId());
    TableBasepage* supplier_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(supplier_basepage_pid, context.getWorkerId()));
    supplier_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), supplier_basepage->column_basepages[SU_SUPPKEY_CID])});
    supplier_column_spec.insert({1, CSVColumnSpec(ParseTypeDescription::Char(25), supplier_basepage->column_basepages[SU_NAME_CID])});
    supplier_column_spec.insert({2, CSVColumnSpec(ParseTypeDescription::Char(40), supplier_basepage->column_basepages[SU_ADDRESS_CID])});
    supplier_column_spec.insert({3, CSVColumnSpec(ParseTypeDescription::Int32(), supplier_basepage->column_basepages[SU_NATIONKEY_CID])});
    supplier_column_spec.insert({4, CSVColumnSpec(ParseTypeDescription::Char(15), supplier_basepage->column_basepages[SU_PHONE_CID])});
    supplier_column_spec.insert({5, CSVColumnSpec(ParseTypeDescription::Decimal(2), supplier_basepage->column_basepages[SU_ACCTBAL_CID])});
    supplier_column_spec.insert({6, CSVColumnSpec(ParseTypeDescription::Char(101), supplier_basepage->column_basepages[SU_COMMENT_CID])});
    pipelines.push_back(std::make_unique<CSVImportPipeline>(10, std::ref(db), joinPath(FLAGS_ch_path, std::string("SUPPLIER.tbl")), CSV_SEP, supplier_column_spec, 7, std::ref(supplier_basepage->cardinality)));
    pipelines.back()->addDependency(pipelines.size() - 2);

    // REGION
    std::unordered_map<size_t, CSVColumnSpec> region_column_spec;
    uint64_t region_tid = db.createTable(db.default_schema_id, "REGION", 3, context.getWorkerId());
    PageId region_basepage_pid = db.getTableBasepageId(region_tid, context.getWorkerId());
    TableBasepage* region_basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixExclusive(region_basepage_pid, context.getWorkerId()));
    region_column_spec.insert({0, CSVColumnSpec(ParseTypeDescription::Int32(), region_basepage->column_basepages[R_REGIONKEY_CID])});
    region_column_spec.insert({1, CSVColumnSpec(ParseTypeDescription::Char(55), region_basepage->column_basepages[R_NAME_CID])});
    region_column_spec.insert({2, CSVColumnSpec(ParseTypeDescription::Char(152), region_basepage->column_basepages[R_COMMENT_CID])});
    pipelines.push_back(std::make_unique<CSVImportPipeline>(11, std::ref(db), joinPath(FLAGS_ch_path, std::string("REGION.tbl")), CSV_SEP, region_column_spec, 3, std::ref(region_basepage->cardinality)));
    pipelines.back()->addDependency(pipelines.size() - 2);

    QEP qep(std::move(pipelines));
    qep.begin(context);
    qep.waitForExecution(context, db.vmcache);
    const size_t num_warehouses = warehouse_basepage->cardinality;
    if (district_basepage->cardinality != 10 * num_warehouses)
        throw UnexpectedCardinalityError("DISTRICT", customer_basepage->cardinality, 10 * num_warehouses);
    if (customer_basepage->cardinality != 30000 * num_warehouses)
        throw UnexpectedCardinalityError("CUSTOMER", customer_basepage->cardinality, 30000 * num_warehouses);
    if (history_basepage->cardinality != 30000 * num_warehouses)
        throw UnexpectedCardinalityError("HISTORY", history_basepage->cardinality, 30000 * num_warehouses);
    if (neworder_basepage->cardinality != 9000 * num_warehouses)
        throw UnexpectedCardinalityError("NEWORDER", neworder_basepage->cardinality, 9000 * num_warehouses);
    if (order_basepage->cardinality != 30000 * num_warehouses)
        throw UnexpectedCardinalityError("ORDER", order_basepage->cardinality, 30000 * num_warehouses);
    if (orderline_basepage->cardinality != 300000 * num_warehouses)
        throw UnexpectedCardinalityError("ORDERLINE", orderline_basepage->cardinality, 300000 * num_warehouses);
    if (item_basepage->cardinality != 100000)
        throw UnexpectedCardinalityError("ITEM", item_basepage->cardinality, 100000);
    if (stock_basepage->cardinality != 100000 * num_warehouses)
        throw UnexpectedCardinalityError("STOCK", stock_basepage->cardinality, 100000 * num_warehouses);
    if (nation_basepage->cardinality != 62)
        throw UnexpectedCardinalityError("NATION", nation_basepage->cardinality, 62);
    if (supplier_basepage->cardinality != 10000)
        throw UnexpectedCardinalityError("SUPPLIER", supplier_basepage->cardinality, 10000);
    if (region_basepage->cardinality != 5)
        throw UnexpectedCardinalityError("REGION", region_basepage->cardinality, 5);
    db.vmcache.unfixExclusive(warehouse_basepage_pid);
    db.vmcache.unfixExclusive(district_basepage_pid);
    db.vmcache.unfixExclusive(customer_basepage_pid);
    db.vmcache.unfixExclusive(history_basepage_pid);
    db.vmcache.unfixExclusive(neworder_basepage_pid);
    db.vmcache.unfixExclusive(order_basepage_pid);
    db.vmcache.unfixExclusive(orderline_basepage_pid);
    db.vmcache.unfixExclusive(item_basepage_pid);
    db.vmcache.unfixExclusive(stock_basepage_pid);
    db.vmcache.unfixExclusive(nation_basepage_pid);
    db.vmcache.unfixExclusive(supplier_basepage_pid);
    db.vmcache.unfixExclusive(region_basepage_pid);
    db.vmcache.printMemoryUsage();

    std::cout << "Creating primary key indexes..." << std::endl;
    db.createPrimaryKeyIndex(warehouse_tid, 1, context);
    db.createPrimaryKeyIndex(district_tid, 2, context);
    db.createPrimaryKeyIndex(customer_tid, 3, context);
    db.createPrimaryKeyIndex(neworder_tid, 3, context);
    db.createPrimaryKeyIndex(order_tid, 3, context);
    db.createPrimaryKeyIndex(orderline_tid, 4, context);
    db.createPrimaryKeyIndex(item_tid, 1, context);
    db.createPrimaryKeyIndex(stock_tid, 2, context);
    db.createPrimaryKeyIndex(nation_tid, 1, context);
    db.createPrimaryKeyIndex(supplier_tid, 1, context);
    db.createPrimaryKeyIndex(region_tid, 1, context);
    db.vmcache.printMemoryUsage();
    return true;
}

void statsCollectorThread(const std::string& path, bool& stop, const DB& db, std::atomic_size_t& no_success_count) {
    std::ofstream file(path);
    if (!file) {
        std::cerr << "Could not open '" << path << "' for writing stats, aborting stats collection" << std::endl;
        stop = true;
        return;
    }
    file << "elapsed,data_pages,temp_pages,faulted_pages";
    if (FLAGS_collect_latched_page_stat)
        file << ",data_latched";
    file << ",temp_in_use";
    file << ",no_success_count";
    file << std::endl;
    size_t prev_no_success_count = 0;
    size_t prev_faulted_pages = 0;
    auto begin = std::chrono::steady_clock::now();
    while (!stop) {
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
        double elapsed_seconds = std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::steady_clock::now() - begin).count();
        file << elapsed_seconds;
        file << "," << db.vmcache.getPartitions().getCurrentPhysicalDataPageCount();
        file << "," << db.vmcache.getMaxPhysicalPages() - db.vmcache.getPartitions().getCurrentPhysicalDataPageCount();
        const size_t faulted_pages = db.vmcache.getTotalFaultedPageCount();
        file << "," << faulted_pages - prev_faulted_pages;
        prev_faulted_pages = faulted_pages;
        if (FLAGS_collect_latched_page_stat)
            file << "," << db.vmcache.getNumLatchedDataPages();
        file << "," << db.vmcache.getNumTemporaryPagesInUse();
        const size_t no_success_count_val = no_success_count.load();
        file << "," << no_success_count_val - prev_no_success_count;
        prev_no_success_count = no_success_count_val;
        file << std::endl;
    }
}

template <size_t n_keys>
bool validateIndexCardinality(DB& db, const std::string& table_name, size_t expected_cardinality, const uint32_t worker_id) {
    PageId basepage_id = db.getTableBasepageId(table_name, worker_id);
    TableBasepage* basepage = reinterpret_cast<TableBasepage*>(db.vmcache.fixShared(basepage_id, worker_id));
    BTree<CompositeKey<n_keys>, PageId> pkey_index(db.vmcache, basepage->primary_key_index_basepage, worker_id);
    db.vmcache.unfixShared(basepage_id);
    size_t cardinality = 0;
    for (__attribute__((unused)) auto val : pkey_index) {
        cardinality++;
    }
    if (cardinality != expected_cardinality) {
        std::cerr << table_name << " primary key index has cardinality " << cardinality << ", expected " << expected_cardinality << std::endl;;
        return false;
    }
    return true;
}

bool validateDatabase(DB& db) {
    bool valid = true;
    const uint32_t worker_id = 0;

    PageId warehouse_basepage_id = db.getTableBasepageId("WAREHOUSE", worker_id);
    const uint32_t num_warehouses = reinterpret_cast<TableBasepage*>(db.vmcache.fixShared(warehouse_basepage_id, worker_id))->cardinality;
    db.vmcache.unfixShared(warehouse_basepage_id);

    valid &= validateIndexCardinality<1>(db, "WAREHOUSE", num_warehouses, worker_id);
    valid &= validateIndexCardinality<2>(db, "DISTRICT", 10 * num_warehouses, worker_id);
    if (FLAGS_full_validation) {
        valid &= validateIndexCardinality<3>(db, "CUSTOMER", 30000 * num_warehouses, worker_id);
        valid &= validateIndexCardinality<3>(db, "NEWORDER", 9000 * num_warehouses, worker_id);
        valid &= validateIndexCardinality<3>(db, "ORDER", 30000 * num_warehouses, worker_id);
        valid &= validateIndexCardinality<4>(db, "ORDERLINE", 300000 * num_warehouses, worker_id);
        valid &= validateIndexCardinality<1>(db, "ITEM", 100000, worker_id);
        valid &= validateIndexCardinality<2>(db, "STOCK", 100000 * num_warehouses, worker_id);
    }
    valid &= validateIndexCardinality<1>(db, "NATION", 62, worker_id);
    valid &= validateIndexCardinality<1>(db, "SUPPLIER", 10000, worker_id);
    valid &= validateIndexCardinality<1>(db, "REGION", 5, worker_id);

    return valid;
}

class DataSource {
public:
    DataSource(uint32_t num_warehouses) : num_warehouses(num_warehouses), generator(0) { }

    int32_t randomUniformInt(int32_t min, int32_t max) {
        std::uniform_int_distribution<int32_t> dist(min, max);
        return dist(generator);
    }

    int32_t randomNonUniformInt(int32_t A, int32_t x, int32_t y, int32_t C) {
        // generate c_id using NURand(1023, 1, 3000), see TPC-C spec, p. 21
        std::uniform_int_distribution<uint32_t> exp1dist(0, A);
        std::uniform_int_distribution<uint32_t> exp2dist(x, y);
        return (((exp1dist(generator) | exp2dist(generator)) + C) % (y - x + 1)) + x;
    }

    int32_t getRemoteWId(int32_t local_w_id) {
        int32_t ret;
        if (num_warehouses == 1) {
            ret = local_w_id;
        } else {
            ret = local_w_id;
            while (ret == local_w_id)
                ret = randomUniformInt(1, num_warehouses);
        }
        return ret;
    }

    uint64_t getCurrentTimestamp() {
        time_t rawtime;
        time(&rawtime);
        tm* timeinfo = localtime(&rawtime);
        return encode_date_time(timeinfo->tm_year + 1900, timeinfo->tm_mon + 1, timeinfo->tm_mday, timeinfo->tm_hour, timeinfo->tm_min, timeinfo->tm_sec);
    }

    std::string genCLast(int32_t value){
        std::string ret;
        ret += c_last_parts[value / 100];
        value %= 100;
        ret += c_last_parts[value / 10];
        value %= 10;
        ret += c_last_parts[value];
        return ret;
    }

    std::string randomCLast() {
        return genCLast(randomNonUniformInt(255, 0, 999, 173));
    }

private:
    const uint32_t num_warehouses;
    std::mt19937 generator;
    std::vector<const char*> c_last_parts = {
        "BAR", "OUGHT", "ABLE", "PRI", "PRES", "ESE", "ANTI", "CALLY", "ATION", "EING"
    };
};

uint64_t runNOWarehouseSelect(DB& db, Identifier w_id, const ExecutionContext context) {
    // select W_TAX from WAREHOUSE where W_ID=?
    std::vector<std::unique_ptr<ExecutablePipeline>> pipelines;
    pipelines.push_back(std::make_unique<ExecutablePipeline>(
        0, db, "WAREHOUSE", w_id,
        std::vector<uint64_t>({ W_TAX_CID }),
        std::vector<NamedColumn>({ W_TAX }),
        context)
    );
    pipelines[0]->addDefaultBreaker(context);
    auto qep = std::make_shared<QEP>(std::move(pipelines));
    qep->begin(context);
    qep->waitForExecution(context, db.vmcache, false);
    std::vector<std::shared_ptr<Batch>> batches;
    qep->getResult()->consumeBatches(batches, context.getWorkerId());
    return *reinterpret_cast<uint64_t*>(batches.front()->getRow(0));
}

uint64_t runNODistrictSelect(DB& db, Identifier w_id, Identifier d_id, const ExecutionContext context) {
    // select D_TAX from DISTRICT where D_W_ID=? and D_ID=?
    std::vector<std::unique_ptr<ExecutablePipeline>> pipelines;
    pipelines.push_back(std::make_unique<ExecutablePipeline>(
        0, db, "DISTRICT", CompositeKey<2> { d_id, w_id },
        std::vector<uint64_t>({ D_TAX_CID }),
        std::vector<NamedColumn>({ D_TAX }),
        context)
    );
    pipelines[0]->addDefaultBreaker(context);
    auto qep = std::make_shared<QEP>(std::move(pipelines));
    qep->begin(context);
    qep->waitForExecution(context, db.vmcache, false);
    std::vector<std::shared_ptr<Batch>> batches;
    qep->getResult()->consumeBatches(batches, context.getWorkerId());
    return *reinterpret_cast<uint64_t*>(batches.front()->getRow(0));
}

void runNODistrictUpdate(DB& db, Identifier w_id, Identifier d_id, const ExecutionContext context) {
    // update DISTRICT set D_NEXT_O_ID=D_NEXT_O_ID+1 where D_W_ID=? and D_ID=?
    // NOTE: we emulate the update by selecting the respective row and materializing the value that should be updated
    std::vector<std::unique_ptr<ExecutablePipeline>> pipelines;
    pipelines.push_back(std::make_unique<ExecutablePipeline>(
        0, db, "DISTRICT", CompositeKey<2> { d_id, w_id },
        std::vector<uint64_t>({ D_NEXT_O_ID_CID }),
        std::vector<NamedColumn>({ D_NEXT_O_ID }),
        context)
    );
    pipelines[0]->addDefaultBreaker(context);
    auto qep = std::make_shared<QEP>(std::move(pipelines));
    qep->begin(context);
    qep->waitForExecution(context, db.vmcache, false);
}

void runNOCustomerSelect(DB& db, Identifier w_id, Identifier d_id, Identifier c_id, uint64_t& c_discount, std::string& c_last, std::string& c_credit, const ExecutionContext context) {
    // select C_DISCOUNT,C_LAST,C_CREDIT from CUSTOMER where C_W_ID=? and C_D_ID=? and C_ID=?
    std::vector<std::unique_ptr<ExecutablePipeline>> pipelines;
    pipelines.push_back(std::make_unique<ExecutablePipeline>(
        0, db, "CUSTOMER", CompositeKey<3> { d_id, w_id, c_id },
        std::vector<uint64_t>({ C_DISCOUNT_CID, C_LAST_CID, C_CREDIT_CID }),
        std::vector<NamedColumn>({ C_DISCOUNT, C_LAST, C_CREDIT }),
        context)
    );
    pipelines[0]->addDefaultBreaker(context);
    auto qep = std::make_shared<QEP>(std::move(pipelines));
    qep->begin(context);
    qep->waitForExecution(context, db.vmcache, false);
    std::vector<std::shared_ptr<Batch>> batches;
    qep->getResult()->consumeBatches(batches, context.getWorkerId());
    c_discount = *reinterpret_cast<uint64_t*>(batches.front()->getRow(0));
    c_last = std::string(reinterpret_cast<char*>(batches.front()->getRow(0)) + C_DISCOUNT.column->getValueTypeSize(), C_LAST.column->getValueTypeSize());
    c_credit = std::string(reinterpret_cast<char*>(batches.front()->getRow(0)) + C_DISCOUNT.column->getValueTypeSize() + C_LAST.column->getValueTypeSize(), C_CREDIT.column->getValueTypeSize());
}

bool runNOItemSelect(DB& db, Identifier i_id, uint64_t& i_price, const ExecutionContext context) {
    // select I_PRICE,I_NAME,I_DATA from ITEM where I_ID=?
    std::vector<std::unique_ptr<ExecutablePipeline>> pipelines;
    pipelines.push_back(std::make_unique<ExecutablePipeline>(
        0, db, "ITEM", i_id,
        std::vector<uint64_t>({ I_PRICE_CID }),
        std::vector<NamedColumn>({ I_PRICE }),
        context)
    );
    pipelines[0]->addDefaultBreaker(context);
    auto qep = std::make_shared<QEP>(std::move(pipelines));
    qep->begin(context);
    qep->waitForExecution(context, db.vmcache, false);
    std::vector<std::shared_ptr<Batch>> batches;
    qep->getResult()->consumeBatches(batches, context.getWorkerId());
    if (batches.empty() || batches.front()->getValidRowCount() == 0)
        return false;
    i_price = *reinterpret_cast<uint64_t*>(batches.front()->getRow(0));
    return true;
}

void runNOStockSelect(DB& db, Identifier d_id, Identifier i_id, Identifier w_id, int32_t& s_quantity, std::string& s_dist, const ExecutionContext context) {
    // select S_QUANTITY,S_DIST_<d_id>,S_DATA from STOCK where S_I_ID=? and S_W_ID=?
    std::vector<std::unique_ptr<ExecutablePipeline>> pipelines;
    pipelines.push_back(std::make_unique<ExecutablePipeline>(
        0, db, "STOCK", CompositeKey<2> { i_id, w_id },
        std::vector<uint64_t>({ S_QUANTITY_CID, S_DIST_01_CID + d_id - 1 }),
        std::vector<NamedColumn>({ S_QUANTITY, S_DIST }),
        context)
    );
    pipelines[0]->addDefaultBreaker(context);
    auto qep = std::make_shared<QEP>(std::move(pipelines));
    qep->begin(context);
    qep->waitForExecution(context, db.vmcache, false);
    std::vector<std::shared_ptr<Batch>> batches;
    qep->getResult()->consumeBatches(batches, context.getWorkerId());
    s_quantity = *reinterpret_cast<int32_t*>(batches.front()->getRow(0));
    s_dist = std::string(reinterpret_cast<char*>(batches.front()->getRow(0)) + S_QUANTITY.column->getValueTypeSize(), S_DIST.column->getValueTypeSize());
}

void runNOStockUpdate(DB& db, Identifier i_id, Identifier w_id, bool is_remote, __attribute__((unused)) int32_t ol_quantity, __attribute__((unused)) int32_t s_quantity, const ExecutionContext context) {
    // if 'is_remote'
    //  update STOCK set S_YTD=S_YTD+?, S_ORDER_CNT=S_ORDER_CNT+1, S_QUANTITY=? where S_I_ID=? and S_W_ID=?
    // else
    //  update STOCK set S_YTD=S_YTD+?, S_ORDER_CNT=S_ORDER_CNT+1, S_QUANTITY=?, S_REMOTE_CNT=S_REMOTE_CNT+1 where S_I_ID=? and S_W_ID=?
    // NOTE: if updates were supported, 'ol_quantity' and 's_quantity' would be used to update 'S_YTD' and 'S_QUANTITY', respectively
    std::vector<std::unique_ptr<ExecutablePipeline>> pipelines;
    auto output_cids = std::vector<uint64_t>({ S_YTD_CID, S_ORDER_CNT_CID, S_QUANTITY_CID });
    auto output_columns = std::vector<NamedColumn>({ S_YTD, S_ORDER_CNT, S_QUANTITY });
    if (is_remote) {
        output_cids.push_back(S_REMOTE_CNT_CID);
        output_columns.push_back(S_REMOTE_CNT);
    }
    pipelines.push_back(std::make_unique<ExecutablePipeline>(
        0, db, "STOCK", CompositeKey<2> { i_id, w_id },
        std::move(output_cids),
        std::move(output_columns),
        context)
    );
    pipelines[0]->addDefaultBreaker(context);
    auto qep = std::make_shared<QEP>(std::move(pipelines));
    qep->begin(context);
    qep->waitForExecution(context, db.vmcache, false);
}

bool executeNewOrder(std::ostream& log, DataSource& ds, DB& db, Identifier w_id, const ExecutionContext context) {
	struct OrderLine {
		int ol_i_id;
		int ol_supply_w_id;
		bool ol_is_remote;
		int ol_quantity;
	};

    // 2.4.1.2
    Identifier d_id = ds.randomUniformInt(1, 10);
    Identifier c_id = ds.randomNonUniformInt(1023, 1, 3000, 867);
    // 2.4.1.3
    uint32_t ol_cnt = ds.randomUniformInt(5, 15);
    // 2.4.1.4
    bool random_rollback = ds.randomUniformInt(1, 100) == 1;
    // 2.4.1.5
	bool all_local = true;
	OrderLine orderlines[15];
	for (size_t i = 0; i < ol_cnt; i++) {
		// 1.
		if (i == ol_cnt - 1 && random_rollback) {
			orderlines[i].ol_i_id = 100001;
        } else {
			orderlines[i].ol_i_id = ds.randomNonUniformInt(8191, 1, 100000, 5867);
        }
		// 2.
		if (ds.randomUniformInt(1, 100) == 1) {
			orderlines[i].ol_supply_w_id = ds.getRemoteWId(w_id);
			orderlines[i].ol_is_remote = true;
			all_local = false;
		} else {
			orderlines[i].ol_supply_w_id = w_id;
			orderlines[i].ol_is_remote = false;
		}
		// 3.
		orderlines[i].ol_quantity = ds.randomUniformInt(1, 10);
	}
	// 2.4.1.6
	auto o_entry_d = ds.getCurrentTimestamp();

    // BEGIN TRANSACTION
    uint64_t w_tax = runNOWarehouseSelect(db, w_id, context);

    uint64_t d_tax = runNODistrictSelect(db, w_id, d_id, context);

    runNODistrictUpdate(db, w_id, d_id, context);

    uint64_t c_discount;
    std::string c_last;
    std::string c_credit;
    runNOCustomerSelect(db, w_id, d_id, c_id, c_discount, c_last, c_credit, context);

    // NOTE: left out due to missing insert support
    // insert into \"ORDER\" values (?,?,?,?,?,NULL,?,?)

    // NOTE: left out due to missing insert support
    // insert into NEWORDER values(?,?,?)

    uint64_t i_price;
    uint64_t total_amount = 0;
	int32_t s_quantity;
	std::string s_dist;
	for (size_t i = 0; i < ol_cnt; i++) {
        if (!runNOItemSelect(db, orderlines[i].ol_i_id, i_price, context)) {
            // expected ROLLBACK
            log << "NewOrder rolled back" << std::endl;
            return true;
        }

        runNOStockSelect(db, d_id, orderlines[i].ol_i_id, orderlines[i].ol_supply_w_id, s_quantity, s_dist, context);

		int32_t new_s_quantity = 0;
		if (orderlines[i].ol_quantity <= s_quantity - 10) {
			new_s_quantity = s_quantity - orderlines[i].ol_quantity;
        } else {
			new_s_quantity = s_quantity - orderlines[i].ol_quantity + 91;
        }
        runNOStockUpdate(db, orderlines[i].ol_i_id, orderlines[i].ol_supply_w_id, orderlines[i].ol_is_remote, orderlines[i].ol_quantity, new_s_quantity, context);

        // insert into ORDERLINE values (?,?,?,?,?,?,NULL,?,?,?)
        // NOTE: left out due to missing insert support
        total_amount += i_price * orderlines[i].ol_quantity;
	}
    log << "[NewOrder] (" << o_entry_d << ") Tax: " << Decimal<2>(w_tax) << " + " << Decimal<2>(d_tax) << ", Total (" << ol_cnt << " order lines): " << Decimal<2>(total_amount);
    if (all_local)
        log << " (all local)";
    log << std::endl;
    return true;
}

Identifier runOSCustomerSelect1(DB& db, Identifier w_id, Identifier d_id, std::string& c_last, const ExecutionContext context) {
    // select C_ID, C_BALANCE, C_FIRST, C_MIDDLE, C_LAST from TPCCH.CUSTOMER where C_LAST=? and C_D_ID=? and C_W_ID=? order by C_FIRST asc
    std::vector<std::unique_ptr<ExecutablePipeline>> pipelines;
    pipelines.push_back(std::make_unique<ExecutablePipeline>(pipelines.size()));
    pipelines.back()->addOperator(std::make_shared<OSCustomerSelectIndexScanOperator>(
        db, c_last, C_LAST,
        CompositeKey<3> { d_id, w_id, std::numeric_limits<Identifier>::min() },
        CompositeKey<3> { d_id, w_id, std::numeric_limits<Identifier>::max() },
        std::vector<uint64_t>({ C_ID_CID, C_BALANCE_CID, C_FIRST_CID, C_MIDDLE_CID, C_LAST_CID }),
        std::vector<NamedColumn>({ C_ID, C_BALANCE, C_FIRST, C_MIDDLE, C_LAST }),
        context));
    pipelines.back()->current_columns.addColumn("C_ID", C_ID.column);
    pipelines.back()->current_columns.addColumn("C_BALANCE", C_BALANCE.column);
    pipelines.back()->current_columns.addColumn("C_FIRST", C_FIRST.column);
    pipelines.back()->current_columns.addColumn("C_MIDDLE", C_MIDDLE.column);
    pipelines.back()->current_columns.addColumn("C_LAST", C_LAST.column);
    pipelines.back()->addSortBreaker(std::vector<NamedColumn>({ C_FIRST }), std::vector<Order>({ Order::Ascending }), context.getWorkerCount());
    pipelines.push_back(std::make_unique<ExecutablePipeline>(pipelines.size()));
    pipelines.back()->addSort(db.vmcache, *pipelines[0].get());
    pipelines.back()->addDefaultBreaker(context);
    auto qep = std::make_shared<QEP>(std::move(pipelines));
    qep->begin(context);
    qep->waitForExecution(context, db.vmcache, false);

    auto result = std::dynamic_pointer_cast<DefaultBreaker>(qep->getResult());
    assert(result != nullptr);
    std::vector<std::shared_ptr<Batch>> batches;
    size_t n = result->getValidRowCount();
    result->consumeBatches(batches, context.getWorkerId());
    size_t i = 0;
    size_t batch_i = 0;
    while (true) {
        if (n / 2 - i < batches[batch_i]->getValidRowCount()) {
            return *reinterpret_cast<Identifier*>(batches[batch_i]->getRow(n / 2 - i));
        }
        i += batches[batch_i]->getValidRowCount();
        batch_i++;
    }
}

std::string runOSCustomerSelect2(DB& db, Identifier c_id, Identifier w_id, Identifier d_id, const ExecutionContext context) {
    // select C_BALANCE, C_FIRST, C_MIDDLE, C_LAST from TPCCH.CUSTOMER where C_ID=? and C_D_ID=? and C_W_ID=?
    std::vector<std::unique_ptr<ExecutablePipeline>> pipelines;
    pipelines.push_back(std::make_unique<ExecutablePipeline>(
        0, db, "CUSTOMER", CompositeKey<3> { d_id, w_id, c_id },
        std::vector<uint64_t>({ C_BALANCE_CID, C_FIRST_CID, C_MIDDLE_CID, C_LAST_CID }),
        std::vector<NamedColumn>({ C_BALANCE, C_FIRST, C_MIDDLE, C_LAST }),
        context)
    );
    pipelines[0]->addDefaultBreaker(context);
    auto qep = std::make_shared<QEP>(std::move(pipelines));
    qep->begin(context);
    qep->waitForExecution(context, db.vmcache, false);
    std::vector<std::shared_ptr<Batch>> batches;
    qep->getResult()->consumeBatches(batches, context.getWorkerId());
    BatchDescription desc;
    qep->getResult()->consumeBatchDescription(desc);
    auto c_last_desc = desc.find("C_LAST");
    const char* c_last = reinterpret_cast<char*>(batches.front()->getRow(0)) + c_last_desc.offset;
    return std::string(c_last, c_last[c_last_desc.column->getValueTypeSize() - 1] != 0 ? c_last_desc.column->getValueTypeSize() : strlen(c_last));
}

Identifier runOSOrderSelect(DB& db, Identifier w_id, Identifier d_id, Identifier c_id, const ExecutionContext context) {
    // select O_ID, O_ENTRY_D, O_CARRIER_ID from TPCCH.\"ORDER\" where O_W_ID=? and O_D_ID=? and O_C_ID=? and O_ID=(select max(O_ID) from TPCCH.\"ORDER\" where O_W_ID=? and O_D_ID=? and O_C_ID=?)
    std::vector<std::unique_ptr<ExecutablePipeline>> pipelines;
    pipelines.push_back(std::make_unique<ExecutablePipeline>(pipelines.size()));
    pipelines.back()->addOperator(std::make_shared<OSOrderSelectIndexScanOperator>(
        db, c_id,
        CompositeKey<3> { d_id, w_id, std::numeric_limits<Identifier>::min() },
        CompositeKey<3> { d_id, w_id, std::numeric_limits<Identifier>::max() },
        std::vector<uint64_t>({ O_ID_CID, O_ENTRY_D_CID, O_CARRIER_ID_CID }),
        std::vector<NamedColumn>({ O_ID, O_ENTRY_D, O_CARRIER_ID }),
        context));
    pipelines.back()->current_columns.addColumn("O_ID", O_ID.column);
    pipelines.back()->current_columns.addColumn("O_ENTRY_D", O_ENTRY_D.column);
    pipelines.back()->current_columns.addColumn("O_CARRIER_ID", O_CARRIER_ID.column);
    pipelines[0]->addDefaultBreaker(context);
    auto qep = std::make_shared<QEP>(std::move(pipelines));
    qep->begin(context);
    qep->waitForExecution(context, db.vmcache, false);
    // return O_ID
    std::vector<std::shared_ptr<Batch>> batches;
    qep->getResult()->consumeBatches(batches, context.getWorkerId());
    return *reinterpret_cast<Identifier*>(batches.front()->getRow(0));
}

size_t runOSOrderlineSelect(DB& db, Identifier w_id, Identifier d_id, Identifier o_id, const ExecutionContext context) {
    // select OL_I_ID, OL_SUPPLY_W_ID, OL_QUANTITY, OL_AMOUNT, OL_DELIVERY_D from TPCCH.ORDERLINE where OL_W_ID=? and OL_D_ID=? and OL_O_ID=?
    std::vector<std::unique_ptr<ExecutablePipeline>> pipelines;
    pipelines.push_back(std::make_unique<ExecutablePipeline>(
        0, db, "ORDERLINE",
        CompositeKey<4> { d_id, w_id, o_id, std::numeric_limits<Identifier>::min() },
        CompositeKey<4> { d_id, w_id, o_id, std::numeric_limits<Identifier>::max() },
        std::vector<uint64_t>({ OL_I_ID_CID, OL_SUPPLY_W_ID_CID, OL_QUANTITY_CID, OL_AMOUNT_CID, OL_DELIVERY_D_CID }),
        std::vector<NamedColumn>({ OL_I_ID, OL_SUPPLY_W_ID, OL_QUANTITY, OL_AMOUNT, OL_DELIVERY_D }),
        context)
    );
    pipelines[0]->addDefaultBreaker(context);
    auto qep = std::make_shared<QEP>(std::move(pipelines));
    qep->begin(context);
    qep->waitForExecution(context, db.vmcache, false);
    auto result = std::dynamic_pointer_cast<DefaultBreaker>(qep->getResult());
    assert(result != nullptr);
    return result->getValidRowCount();
}

bool executeOrderStatus(std::ostream& log, DataSource& ds, DB& db, Identifier w_id, const ExecutionContext context) {
	// 2.6.1.2
	int32_t d_id = ds.randomUniformInt(1, 10);
	int32_t y = ds.randomUniformInt(1, 100);
	int32_t c_id = 0;
	std::string c_last;
	if (y <= 60) {
		c_last = ds.randomCLast();
	} else {
		c_id = ds.randomNonUniformInt(1023, 1, 3000, 867);
	}

    // BEGIN TRANSACTION
	if (y <= 60) {
        c_id = runOSCustomerSelect1(db, w_id, d_id, c_last, context);
    } else {
        c_last = runOSCustomerSelect2(db, c_id, w_id, d_id, context);
    }

    Identifier o_id = runOSOrderSelect(db, w_id, d_id, c_id, context);

    size_t orderline_count = runOSOrderlineSelect(db, w_id, d_id, o_id, context);

    log << "[OrderStatus] (" << w_id << ", " << d_id << ") " << c_last << " (" << c_id << ") order id " << o_id << ": " << orderline_count << " order lines" << std::endl;
    return true;
}

enum class BenchmarkState {
    Warmup,
    Benchmark,
    Done
};

class LatencyLog {
public:
    // no logging
    LatencyLog() { }

    // log to file at 'path'
    LatencyLog(const std::string& path) : file(path) {
        if (!file)
            throw std::runtime_error("Failed to open latency log file for writing");
        // measurement = [query or transaction name]
        // time = [runtime in microseconds]
        file << "measurement,time" << std::endl;
    }

    void log(const std::string& measurement, size_t time_us) {
        if (!file)
            return;
        std::lock_guard<std::mutex> guard(fmutex);
        file << measurement << "," << time_us << "\n";
    }

private:
    std::ofstream file;
    std::mutex fmutex;
};

void OLTPStream(std::atomic<BenchmarkState>& state, std::atomic_size_t& active_streams, std::ostream& log, LatencyLog& llog, DB& db, std::atomic_size_t& no_success_count, uint32_t num_warehouses, Identifier w_id, Identifier d_id, const ExecutionContext context) {
    DataSource ds(num_warehouses);

    int32_t decision;
    uint32_t success_count[5] = {};
    uint32_t fail_count[5] = {};
    BenchmarkState prev_state = state.load();
    auto begin = std::chrono::steady_clock::now();
    while (state != BenchmarkState::Done) {
        BenchmarkState curr_state = state.load();
        if (curr_state == BenchmarkState::Benchmark && prev_state == BenchmarkState::Warmup) {
            begin = std::chrono::steady_clock::now();
        }
        prev_state = curr_state;
        decision = ds.randomUniformInt(1, 100);
        if (decision <= 44) {
            auto txn_begin = std::chrono::steady_clock::now();
            if (executeNewOrder(log, ds, db, w_id, context)) {
                no_success_count++;
                if (state == BenchmarkState::Benchmark)
                    success_count[0]++;
            } else {
                if (state == BenchmarkState::Benchmark)
                    fail_count[0]++;
            }
            llog.log("N", std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::steady_clock::now() - txn_begin).count());
        }
        decision = ds.randomUniformInt(1, 100);
        if (decision <= 44) {
            // TODO: executePayment(log, ds, db, w_id, context);
        }
        decision = ds.randomUniformInt(1, 100);
        if (decision <= 4) {
            auto txn_begin = std::chrono::steady_clock::now();
            if (executeOrderStatus(log, ds, db, w_id, context)) {
                if (state == BenchmarkState::Benchmark)
                    success_count[2]++;
            } else {
                if (state == BenchmarkState::Benchmark)
                    fail_count[2]++;
            }
            llog.log("O", std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::steady_clock::now() - txn_begin).count());
        }
        decision = ds.randomUniformInt(1, 100);
        if (decision <= 4) {
            // TODO: executeDelivery(log, ds, db, w_id, context);
        }
        decision = ds.randomUniformInt(1, 100);
        if (decision <= 4) {
            // TODO: executeStockLevel(log, ds, db, w_id, d_id context);
        }
    }
    // 5.4.2
    //double mqth = success_count[0] / std::chrono::duration_cast<std::chrono::duration<double, std::ratio<60>>>(std::chrono::steady_clock::now() - begin).count();
    //std::cout << "Transaction throughput: " << size_t(mqth) << " tpmC" << std::endl;
    active_streams--;
}

void OLAPStream(std::atomic<BenchmarkState>& state, std::atomic_size_t& active_streams, std::ostream& log, LatencyLog& llog, DB& db, const ExecutionContext context) {
    std::vector<double> response_times;
    BenchmarkState prev_state = state.load();
    auto begin = std::chrono::steady_clock::now();
    while (state != BenchmarkState::Done) {
        auto q_begin = std::chrono::steady_clock::now();
        BenchmarkState curr_state = state.load();
        if (curr_state == BenchmarkState::Benchmark && prev_state == BenchmarkState::Warmup) {
            begin = std::chrono::steady_clock::now();
        }
        prev_state = curr_state;

        if (state == BenchmarkState::Warmup)
            continue;

        if (FLAGS_real_olap) {
            log << "Running q09..." << std::endl;
            /*
                select	 n_name, extract(year from o_entry_d) as l_year, sum(ol_amount) as sum_profit
                from	 "ITEM", "STOCK", "SUPPLIER", "ORDERLINE", "ORDER", "NATION"
                where	 ol_i_id = s_i_id
                    and ol_supply_w_id = s_w_id
                    and mod((s_w_id * s_i_id), 10000) = su_suppkey
                    and ol_w_id = o_w_id
                    and ol_d_id = o_d_id
                    and ol_o_id = o_id
                    and ol_i_id = i_id
                    and su_nationkey = n_nationkey
                    and i_data like '%BB'
                group by n_name, extract(year from o_entry_d)
                order by n_name, l_year desc
            */

            std::vector<std::unique_ptr<ExecutablePipeline>> pipelines;
            // (0) scan NATION into JoinBreaker for SUPPLIER join
            pipelines.push_back(std::make_unique<ExecutablePipeline>(pipelines.size(), db, "NATION", std::vector<uint64_t>({ N_NATIONKEY_CID, N_NAME_CID }), std::vector<NamedColumn>({ N_NATIONKEY, N_NAME }), context));
            pipelines.back()->addJoinBreaker(db.vmcache, context);

            // (1) + (2) hash build for (0)
            JoinFactory::createBuildPipelines(pipelines, db.vmcache, *pipelines.back(), N_NATIONKEY.column->getValueTypeSize());

            // (3) scan SUPPLIER, join on (2), into JoinBreaker for STOCK join
            pipelines.push_back(std::make_unique<ExecutablePipeline>(pipelines.size(), db, "SUPPLIER", std::vector<uint64_t>({ SU_NATIONKEY_CID, SU_SUPPKEY_CID }), std::vector<NamedColumn>({ SU_NATIONKEY, SU_SUPPKEY }), context));
            pipelines.back()->addJoinProbe(db.vmcache, *pipelines[2], std::vector<NamedColumn>({ SU_SUPPKEY, N_NAME }));
            pipelines.back()->addJoinBreaker(db.vmcache, context);

            // (4) + (5) hash build for (3)
            JoinFactory::createBuildPipelines(pipelines, db.vmcache, *pipelines.back(), SU_SUPPKEY.column->getValueTypeSize());

            // (6) scan STOCK, compute '(S_W_ID * S_I_ID) % 10000' as the join key, join on (5), into JoinBreaker for ORDERLINE, ORDER, ITEM join
            // TODO: simplify this using ExecutablePipeline's specialised scan constructor once the general-purpose scan operator can do the necessary input transformations or we have a seperate operator for performing arithmetic operations
            pipelines.push_back(std::make_unique<ExecutablePipeline>(pipelines.size()));
            auto p6_output_columns = std::vector<NamedColumn>({ S_SUPPKEY, S_W_ID, S_I_ID });
            for (const auto& col : p6_output_columns) {
                pipelines.back()->current_columns.addColumn(col.name, col.column);
            }
            pipelines.back()->addOperator(std::make_shared<Q09StockScanOperator>(db, std::move(p6_output_columns), context));
            pipelines.back()->addJoinProbe(db.vmcache, *pipelines[5], std::vector<NamedColumn>({
                S_W_ID,
                S_I_ID,
                N_NAME
            }));
            pipelines.back()->addJoinBreaker(db.vmcache, context);

            // (7) + (8) hash build for (6)
            JoinFactory::createBuildPipelines(pipelines, db.vmcache, *pipelines.back(), S_W_ID.column->getValueTypeSize() + S_I_ID.column->getValueTypeSize());

            // (9) scan ITEM into JoinBreaker for ORDERLINE join
            pipelines.push_back(std::make_unique<ExecutablePipeline>(pipelines.size()));
            auto p9_output_columns = std::vector<NamedColumn>({ I_ID });
            for (const auto& col : p9_output_columns) {
                pipelines.back()->current_columns.addColumn(col.name, col.column);
            }
            pipelines.back()->addOperator(std::make_shared<Q09ItemScanOperator>(db, std::move(p9_output_columns), context));
            pipelines.back()->addJoinBreaker(db.vmcache, context);

            // (10) + (11) hash build for (9)
            JoinFactory::createBuildPipelines(pipelines, db.vmcache, *pipelines.back(), I_ID.column->getValueTypeSize());

            // (12) scan ORDERLINE, join on ITEM, into JoinBreaker for ORDER join
            pipelines.push_back(std::make_unique<ExecutablePipeline>(pipelines.size(), db, "ORDERLINE", std::vector<uint64_t>({ OL_I_ID_CID, OL_W_ID_CID, OL_D_ID_CID, OL_O_ID_CID, OL_SUPPLY_W_ID_CID, OL_AMOUNT_CID }), std::vector<NamedColumn>({ OL_I_ID, OL_W_ID, OL_D_ID, OL_O_ID, OL_SUPPLY_W_ID, OL_AMOUNT }), context));
            pipelines.back()->addJoinProbe(db.vmcache, *pipelines[11], std::vector<NamedColumn>({ OL_W_ID, OL_D_ID, OL_O_ID, OL_I_ID, OL_SUPPLY_W_ID, OL_AMOUNT }));
            pipelines.back()->addJoinBreaker(db.vmcache, context);

            // (13) + (14) hash build for (12)
            JoinFactory::createBuildPipelines(pipelines, db.vmcache, *pipelines.back(), OL_W_ID.column->getValueTypeSize() + OL_D_ID.column->getValueTypeSize() + OL_O_ID.column->getValueTypeSize());

            // (15) scan ORDER, join on (14) and (8), into sort breaker
            pipelines.push_back(std::make_unique<ExecutablePipeline>(pipelines.size()));
            auto p15_output_columns = std::vector<NamedColumn>({ O_W_ID, O_D_ID, O_ID, L_YEAR });
            for (const auto& col : p15_output_columns) {
                pipelines.back()->current_columns.addColumn(col.name, col.column);
            }
            pipelines.back()->addOperator(std::make_shared<Q09OrderScanOperator>(db, std::vector<uint64_t>({ O_W_ID_CID, O_D_ID_CID, O_ID_CID, O_ENTRY_D_CID }), std::move(p15_output_columns), context));
            pipelines.back()->addJoinProbe(db.vmcache, *pipelines[14], std::vector<NamedColumn>({ OL_SUPPLY_W_ID, OL_I_ID, OL_AMOUNT, L_YEAR }));
            pipelines.back()->addJoinProbe(db.vmcache, *pipelines[8], std::vector<NamedColumn>({ N_NAME, L_YEAR, OL_AMOUNT }));
            pipelines.back()->addSortBreaker(std::vector<NamedColumn>({ N_NAME, L_YEAR }), std::vector<Order>({ Order::Ascending, Order::Descending }), context.getWorkerCount());

            // (16) sort (15), aggregate SUM(OL_AMOUNT) grouped by N_NAME, L_YEAR
            pipelines.push_back(std::make_unique<ExecutablePipeline>(pipelines.size()));
            pipelines.back()->addSort(db.vmcache, *pipelines[pipelines.size() - 2]);
            BatchDescription final_output_desc = BatchDescription(std::vector<NamedColumn>({ N_NAME, L_YEAR, SUM_PROFIT }));
            pipelines.back()->addBreaker(std::make_shared<Q09AggregationOperator>(db, final_output_desc));

            auto qep = std::make_shared<QEP>(std::move(pipelines));
            qep->begin(context);
            qep->waitForExecution(context, db.vmcache, false);
            printQueryResult(qep->getResult(), context.getWorkerId(), log);
            qep = nullptr;
        } else {
            log << "Simulating OLAP query..." << std::endl;
            const size_t num_pages = std::min(db.vmcache.getMaxPhysicalPages() * 50ull / 100ull, 4ull * 1024ull * 1024ull * 1024ull / PAGE_SIZE);
            const size_t batch_size = num_pages;
            size_t allocated_pages = 0;
            std::vector<char*> pages;
            // "analytical query": allocate a large number of temporary pages in vmcache
            while (state != BenchmarkState::Done && allocated_pages < num_pages) {
                pages.push_back(db.vmcache.allocateTemporaryHugePage(batch_size, context.getWorkerId()));
                allocated_pages += batch_size;
            }
            llog.log("alloc", std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::steady_clock::now() - q_begin).count());
            // hold allocated pages
            while (std::chrono::steady_clock::now() - q_begin < std::chrono::seconds(5)) {
                std::this_thread::sleep_for(std::chrono::microseconds(500));
            }
            auto dealloc_begin = std::chrono::steady_clock::now();
            // drop allocated pages
            for (auto& page : pages) {
                db.vmcache.dropTemporaryHugePage(page, batch_size, context.getWorkerId());
            }
            llog.log("free", std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::steady_clock::now() - dealloc_begin).count());
        }
        auto q_elapsed = std::chrono::steady_clock::now() - q_begin;
        response_times.push_back(std::chrono::duration_cast<std::chrono::duration<double>>(q_elapsed).count());
        llog.log(FLAGS_real_olap ? "q09" : "sim_olap", std::chrono::duration_cast<std::chrono::microseconds>(q_elapsed).count());
        // wait between each query execution
        while (state != BenchmarkState::Done && std::chrono::steady_clock::now() - q_begin < std::chrono::seconds(30)) {
            std::this_thread::sleep_for(std::chrono::microseconds(500));
        }
    }
    if (!response_times.empty()) {
        std::sort(response_times.begin(), response_times.end());
        std::cout << "Analytical mean response time: " << std::setprecision(3) << response_times[response_times.size() / 2] << " s" << std::endl;
        std::cout << "Analytical throughput: " << std::setprecision(3) << response_times.size() / std::chrono::duration_cast<std::chrono::duration<double>>(std::chrono::steady_clock::now() - begin).count() << " queries/s" << std::endl;
    } else {
        std::cout << "No analytical queries completed within the benchmark period!" << std::endl;
    }
    active_streams--;
}

int main(int argc, char** argv) {
#ifdef VTUNE_PROFILING
    __itt_task_begin(itt_domain, __itt_null, __itt_null, itt_handle_setup);
#endif

    gflags::ParseCommandLineFlags(&argc, &argv, true);
    if (argc != 2) {
        std::cout << "Error: Missing database path" << std::endl;
        return -1;
    }

    const char* const supported_partitioning_strategies[] = { "basic", "partitioned" };
    bool partitioning_strategy_valid = false;
    for (size_t i = 0; i < sizeof(supported_partitioning_strategies) / sizeof(supported_partitioning_strategies[0]); i++) {
        if (FLAGS_partitioning_strategy == supported_partitioning_strategies[i]) {
            partitioning_strategy_valid = true;
            break;
        }
    }
    if (!partitioning_strategy_valid) {
        std::cout << "Error: " << FLAGS_partitioning_strategy << " is not a supported partitioning strategy" << std::endl;
        return -1;
    }

    const char* const supported_eviction_policies[] = { "clock", "random", "mru" };
    bool eviction_policy_valid = false;
    for (size_t i = 0; i < sizeof(supported_eviction_policies) / sizeof(supported_eviction_policies[0]); i++) {
        if (FLAGS_eviction_policy == supported_eviction_policies[i]) {
            eviction_policy_valid = true;
            break;
        }
    }
    if (!eviction_policy_valid) {
        std::cout << "Error: " << FLAGS_eviction_policy << " is not a supported eviction policy" << std::endl;
        return -1;
    }

    std::string path(argv[1]);
    struct stat st;
    bool create = false;
    int flags = O_RDWR | O_DIRECT;
    if (stat(path.c_str(), &st) != 0) {
        std::cout << "Creating new database..." << std::endl;
        create = true;
        flags |= O_CREAT;
    }
    int fd = open(path.c_str(), flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
    if (fd == -1) {
        std::cout << "Error: Failed to open database file (errno " << errno << ", " << errnoStr() << ")" << std::endl;
        errno = 0;
        return -1;
    }

    // set up eviction policy
    std::unique_ptr<PartitioningStrategy> partitioning_strategy;
    if (FLAGS_partitioning_strategy == "basic") {
        partitioning_strategy = createPartitioningStrategy<BasicPartitioningStrategy>(FLAGS_eviction_policy);
    } else if (FLAGS_partitioning_strategy == "partitioned") {
        if (FLAGS_partitioned_num_temp_pages == 0) {
            std::cout << "Error: Please specify a non-zero value for 'partitioned_num_temp_pages' for the partitioned strategy!" << std::endl;
            return -1;
        }
        partitioning_strategy = createPartitioningStrategy<DataTempPartitioningStrategy>(FLAGS_eviction_policy, FLAGS_partitioned_num_temp_pages);
    }

    int ret = 0;
    {
        JobManager job_manager(FLAGS_parallel);
        DB db(FLAGS_memory_limit, fd, create, job_manager.getWorkerCount(), true, std::move(partitioning_strategy));
        ExecutionContext context(job_manager, 0, 0);

#ifdef VTUNE_PROFILING
        __itt_task_end(itt_domain);
#endif
        if (create) {
#ifdef VTUNE_PROFILING
            __itt_task_begin(itt_domain, __itt_null, __itt_null, itt_handle_load);
#endif
            // load data
            if (FLAGS_ch_path.length() == 0) {
                std::cout << "Error: Missing value for argument ch_path" << std::endl;
                ret = -1;
            } else if (!loadDatabase(db, context)) {
                ret = -1;
            }
#ifdef VTUNE_PROFILING
            __itt_task_end(itt_domain);
#endif
        }

        bool stop_stats_collection = false;
        std::unique_ptr<std::thread> stats_collector_thread;
        std::atomic_size_t no_success_count(0);
        if (!FLAGS_collect_stats.empty()) {
            // begin statistics collection
            stats_collector_thread = std::make_unique<std::thread>(statsCollectorThread, std::ref(FLAGS_collect_stats), std::ref(stop_stats_collection), std::ref(db), std::ref(no_success_count));
        }

        // run benchmark
        if (!FLAGS_import_only) {
            if (FLAGS_oltp + 2 > job_manager.getWorkerCount()) {
                ret = -1;
                std::cerr << "Number of OLTP streams (" << FLAGS_oltp << ") must be at least 2 fewer than the number of worker threads (" << job_manager.getWorkerCount() << ")" << std::endl;
            } else if (validateDatabase(db)) {
                std::atomic<BenchmarkState> state(BenchmarkState::Warmup);
                std::atomic_size_t active_streams(0);

                PageId warehouse_basepage_id = db.getTableBasepageId("WAREHOUSE", context.getWorkerId());
                const uint32_t num_warehouses = reinterpret_cast<TableBasepage*>(db.vmcache.fixShared(warehouse_basepage_id, context.getWorkerId()))->cardinality;
                db.vmcache.unfixShared(warehouse_basepage_id);
                std::cout << "Running benchmarks with " << num_warehouses << " warehouses and " << FLAGS_oltp << " OLTP streams" << std::endl;
                DataSource ds(num_warehouses);
                std::ofstream log; // for now just suppress log output from streams, may change this later on
                //auto& log = std::cout;
                LatencyLog llog = FLAGS_latency_log.empty() ? LatencyLog() : LatencyLog(FLAGS_latency_log);
                std::vector<std::function<void(const ExecutionContext)>> oltp_tasks;
                std::set<uint64_t> used_w_d_id_combinations;
                for (size_t i = 0; i < FLAGS_oltp; i++) {
                    Identifier w_id;
                    Identifier d_id;
                    uint64_t combination;
                    do {
                        // 2.4.1.1
                        w_id = ds.randomUniformInt(1, num_warehouses);
                        // 2.8.1.1
                        d_id = ds.randomUniformInt(1, 10);
                        // for checking if we already used this combination
                        combination = static_cast<uint64_t>(w_id) << 32 | d_id;
                    } while (used_w_d_id_combinations.find(combination) != used_w_d_id_combinations.end());
                    used_w_d_id_combinations.emplace(combination);
                    oltp_tasks.push_back(std::bind(OLTPStream, std::ref(state), std::ref(active_streams), std::ref(log), std::ref(llog), std::ref(db), std::ref(no_success_count), num_warehouses, w_id, d_id, std::placeholders::_1));
                }
                auto olap_task = std::bind(OLAPStream, std::ref(state), std::ref(active_streams), std::ref(log), std::ref(llog), std::ref(db), std::placeholders::_1);

                for (auto& task : oltp_tasks) {
                    job_manager.getDispatcher().scheduleTask(task); active_streams++;
                }
                job_manager.getDispatcher().scheduleTask(olap_task); active_streams++;

                const auto warmup_time = std::chrono::seconds(FLAGS_warmup);
                const auto benchmark_time = std::chrono::seconds(FLAGS_benchmark);
                for (size_t i = 0; i < 2; i++) {
                    if (i == 0) {
                        std::cout << "Beginning warmup (" << FLAGS_warmup << " s) ..." << std::endl;
                    } else {
                        std::cout << "Beginning benchmark (" << FLAGS_benchmark << " s) ..." << std::endl;
                    }
                    auto begin = std::chrono::steady_clock::now();
                    const auto run_time = i == 0 ? warmup_time : benchmark_time;
                    while (std::chrono::steady_clock::now() - begin < run_time) {
                        std::this_thread::sleep_for(std::chrono::milliseconds(1));
                    }
                    if (i == 0) {
                        state.store(BenchmarkState::Benchmark);
                    } else {
                        std::cout << "Ending benchmark..." << std::endl;
                        state.store(BenchmarkState::Done);
                    }
                }
                // wait for last queries/txns to finish before shutting down worker threads
                while (active_streams > 0) {
                    std::this_thread::sleep_for(std::chrono::milliseconds(1));
                }
            }
        }

        if (!FLAGS_collect_stats.empty()) {
            // stop statistics collection
            stop_stats_collection = true;
            stats_collector_thread->join();
        }

        job_manager.stop();
    }
    close(fd);

    return ret;
}